<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON - Heatmap</title>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <!-- GeoTIFF解析用ライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.1.1/dist-browser/geotiff.js"></script>
    <!-- 座標系変換用ライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.0/dist/proj4.js"></script>
    <!-- Turf.js（計測用） -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <!-- カスタムスタイルシート -->
    <link href="styles.css" rel="stylesheet" />
</head>
<body>
    <div id="map"></div>
    
    <!-- ドラッグ&ドロップ用のオーバーレイ -->
    <div class="drop-overlay" id="dropOverlay">
        <div class="drop-message">
            <div>ファイルをここにドロップ</div>
            <div style="font-size: 14px; margin-top: 10px; font-weight: normal;">
                GeoJSON: .geojson, .json<br>
                GeoTIFF: .tif, .tiff
            </div>
        </div>
    </div>
    
    <!-- ファイル選択ボタン -->
    <div class="file-input-container minimized" id="fileInputContainer">
        <div class="panel-header">
            <h4>GeoJson選択・画面上にドロップ</h4>
            <button class="close-button" id="fileInputClose" title="最小化">×</button>
        </div>
        <div class="file-input-content">
            <input type="file" id="fileInput" accept=".geojson,.json">
        </div>
        <div class="minimized-text">選択</div>
    </div>
    
    <!-- 表示設定パネル（GeoJSON読み込み後に表示） -->
    <div class="controls" id="controls" style="display: none;">
        <div class="panel-header">
            <h4>表示設定</h4>
            <button class="close-button" id="controlsClose" title="最小化">×</button>
        </div>
        <div class="controls-content">
            <div class="field-selector">
                <label for="fieldSelect">表示フィールド:</label>
                <select id="fieldSelect">
                    <option value="">選択してください</option>
                </select>
            </div>
            <div class="label-mode">
                <label>
                    <input type="checkbox" id="labelMode" checked> 文字ラベル表示
                </label>
            </div>
            <div class="color-mode">
                <label>
                    <input type="checkbox" id="heatmapMode"> ヒートマップ表示
                </label>
            </div>
            <div class="line-width-control">
                <label for="lineWidth">ライン幅:</label>
                <div class="line-width-controls">
                    <input type="range" id="lineWidth" min="0" max="3" value="2" step="0.1">
                    <div class="line-width-value" id="lineWidthValue">2.0</div>
                </div>
            </div>
            <div class="color-legend" id="colorLegend" style="display: none;">
                <h5>色分け凡例</h5>
                <div id="legendContent"></div>
            </div>
            <div class="info">
                <div>フィーチャ数: <span id="featureCount">0</span></div>
                <div id="fieldInfo" style="margin-top: 5px;"></div>
            </div>
            <div id="status"></div>
        </div>
        <div class="minimized-text">表示</div>
    </div>

    <!-- 背景地図コントロール -->
    <div class="basemap-controls minimized" id="basemapControls">
        <div class="panel-header">
            <h4>背景地図</h4>
            <button class="close-button" id="basemapClose" title="最小化">×</button>
        </div>
        <div class="basemap-content">
            <div class="basemap-selector">
                <label for="basemapSelect">地図種別:</label>
                <select id="basemapSelect">
                    <option value="osm">OpenStreetMap</option>
                    <option value="gsi-pale">地理院地図（淡色）</option>
                    <option value="gsi-photo">地理院地図（写真）</option>
                </select>
            </div>
            <div class="basemap-opacity">
                <label for="basemapOpacity">透明度:</label>
                <div class="opacity-controls">
                    <input type="range" id="basemapOpacity" min="0" max="100" value="100" step="1">
                    <div class="opacity-value" id="opacityValue">100%</div>
                </div>
            </div>
        </div>
        <div class="minimized-text">背景</div>
    </div>

    <!-- GeoTIFFコントロール -->
    <div class="geotiff-controls minimized" id="geotiffControls">
        <div class="panel-header">
            <h4>GeoTIFF</h4>
            <button class="close-button" id="geotiffClose" title="最小化">×</button>
        </div>
        <div class="geotiff-content">
            <div class="geotiff-file-input">
                <input type="file" id="geotiffInput" accept=".tif,.tiff" title="GeoTIFFファイルを選択">
            </div>
            <div class="geotiff-opacity">
                <label for="geotiffOpacity">透明度:</label>
                <div class="geotiff-opacity-controls">
                    <input type="range" id="geotiffOpacity" min="0" max="100" value="70" step="1">
                    <div class="geotiff-opacity-value" id="geotiffOpacityValue">70%</div>
                </div>
            </div>
            <div id="geotiffStatus" class="geotiff-status" style="display: none;"></div>
            <button id="geotiffRemove" class="geotiff-remove-btn" style="display: none;">GeoTIFF削除</button>
        </div>
        <div class="minimized-text">TIFF</div>
    </div>

    <!-- 計測コントロール -->
    <div class="measure-controls minimized" id="measureControls">
        <div class="panel-header">
            <h4>計測ツール</h4>
            <button class="close-button" id="measureClose" title="最小化">×</button>
        </div>
        <div class="measure-content">
            <div class="measure-buttons">
                <button class="measure-btn" id="measureDistance">距離計測</button>
                <button class="measure-btn" id="measureArea">面積計測</button>
            </div>
            <div id="measureResult" class="measure-result"></div>
            <button id="measureClear" class="measure-clear">計測をクリア</button>
        </div>
        <div class="minimized-text">計測</div>
    </div>

    <!-- 座標系変換ダイアログ -->
    <div class="crs-dialog-overlay" id="crsDialogOverlay" style="display: none;">
        <div class="crs-dialog">
            <div class="crs-dialog-header">
                <h3>座標系変換</h3>
            </div>
            <div class="crs-dialog-content">
                <p>このGeoJSONデータはWGS84座標系ではない可能性があります。</p>
                <p>データの測地系を指定してください。</p>
                
                <div class="crs-options">
                    <label class="crs-option">
                        <input type="radio" name="sourceCrs" value="jgd2011" checked>
                        <span class="crs-label">JGD2011 日本測地系2011</span>
                        <span class="crs-description">平面直角座標系を選択してください</span>
                        <div class="zone-selector" style="margin-top: 10px;">
                            <select id="jgd2011Zone" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="6677">9系 (EPSG:6677) - 群馬県・東京都・その他関東地方</option>
                                <option value="6675">7系 (EPSG:6675) - 石川県・富山県・岐阜県・愛知県</option>
                                <option value="6676">8系 (EPSG:6676) - 新潟県・長野県・山梨県・静岡県</option>
                                <option value="6678">10系 (EPSG:6678) - 青森県・秋田県・山形県・岩手県・宮城県</option>
                                <option value="6679">11系 (EPSG:6679) - 北海道の一部（小樽市・函館市など）</option>
                            </select>
                        </div>
                    </label>
                </div>
                
                <div class="crs-dialog-buttons">
                    <button class="crs-btn-cancel" id="crsCancel">キャンセル</button>
                    <button class="crs-btn-convert" id="crsConvert">変換して読み込み</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 前橋市役所の座標 (緯度: 36.389494, 経度: 139.063437)
        const MAEBASHI_CITY_HALL = [139.063437, 36.389494];
        
        // 背景地図の定義
        const basemapStyles = {
            osm: {
                'version': 8,
                'glyphs': 'https://fonts.openmaptiles.org/{fontstack}/{range}.pbf',
                'sources': {
                    'osm': {
                        'type': 'raster',
                        'tiles': [
                            'https://tile.openstreetmap.org/{z}/{x}/{y}.png'
                        ],
                        'tileSize': 256,
                        'attribution': '© OpenStreetMap contributors'
                    }
                },
                'layers': [{
                    'id': 'basemap',
                    'type': 'raster',
                    'source': 'osm'
                }]
            },
            'gsi-pale': {
                'version': 8,
                'glyphs': 'https://fonts.openmaptiles.org/{fontstack}/{range}.pbf',
                'sources': {
                    'gsi-pale': {
                        'type': 'raster',
                        'tiles': [
                            'https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png'
                        ],
                        'tileSize': 256,
                        'attribution': '© 国土地理院'
                    }
                },
                'layers': [{
                    'id': 'basemap',
                    'type': 'raster',
                    'source': 'gsi-pale'
                }]
            },
            'gsi-photo': {
                'version': 8,
                'glyphs': 'https://fonts.openmaptiles.org/{fontstack}/{range}.pbf',
                'sources': {
                    'gsi-photo': {
                        'type': 'raster',
                        'tiles': [
                            'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg'
                        ],
                        'tileSize': 256,
                        'attribution': '© 国土地理院'
                    }
                },
                'layers': [{
                    'id': 'basemap',
                    'type': 'raster',
                    'source': 'gsi-photo'
                }]
            }
        };
        
        // マップの初期化
        const map = new maplibregl.Map({
            container: 'map',
            style: basemapStyles.osm,
            center: MAEBASHI_CITY_HALL,
            zoom: 15,
            maxZoom: 22
        });
        
        // 標準コントロールを追加
        map.addControl(new maplibregl.NavigationControl(), 'top-right');
        
        // 現在位置取得コントロールを追加
        map.addControl(new maplibregl.GeolocateControl({
            positionOptions: {
                enableHighAccuracy: true  // 高精度位置情報を使用
            },
            trackUserLocation: true,      // ユーザーの位置を追跡
            showUserHeading: true,        // ユーザーの向きを表示
            showAccuracyCircle: true      // 精度円を表示
        }), 'top-right');
        
        // 前橋市役所にマーカーを追加
        new maplibregl.Marker({ color: '#ff0000' })
            .setLngLat(MAEBASHI_CITY_HALL)
            .setPopup(new maplibregl.Popup().setHTML('<h4>前橋市役所</h4>'))
            .addTo(map);
        
        let currentGeoJSON = null;
        let currentField = null;
        let isHeatmapMode = false;
        
        // 複数GeoJSON管理用の変数
        let geoJSONLayerCounter = 0;
        let isFirstGeoJSON = true;
        let isLabelMode = true;
        let fieldStats = null;
        let currentBasemap = 'osm';
        let currentGeoTIFF = null;
        let geotiffCanvas = null;
        
        // 計測関連変数
        let measureMode = null; // 'distance', 'area', null
        let measurePoints = [];
        let measureMarkers = [];
        let measureLines = [];
        let measurePolygons = [];
        
        // 座標系変換関連変数
        let pendingGeoJSON = null;
        let pendingGeoTIFF = null;
        let crsDialogOverlay = null;
        let currentDialogType = 'geojson'; // 'geojson' または 'geotiff'
        
        // 座標系定義（Proj4js用）
        const crsDefinitions = {
            // JGD2011 平面直角座標系 7系～11系
            '6675': '+proj=tmerc +lat_0=36 +lon_0=137.166666666667 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs', // 7系
            '6676': '+proj=tmerc +lat_0=36 +lon_0=138.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs', // 8系
            '6677': '+proj=tmerc +lat_0=36 +lon_0=139.833333333333 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs', // 9系
            '6678': '+proj=tmerc +lat_0=40 +lon_0=137.166666666667 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs', // 10系
            '6679': '+proj=tmerc +lat_0=40 +lon_0=138.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs', // 11系
            // その他の座標系（後方互換のため保持）
            '6668': '+proj=tmerc +lat_0=33 +lon_0=129.5 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs',
            '2451': '+proj=tmerc +lat_0=36 +lon_0=139.833333333333 +k=0.9999 +x_0=0 +y_0=0 +ellps=bessel +towgs84=-146.414,507.337,680.507,0,0,0,0 +units=m +no_defs'
        };
        
        // Proj4js投影を初期化
        const initializeProjections = () => {
            try {
                // WGS84
                proj4.defs('EPSG:4326', '+proj=longlat +datum=WGS84 +no_defs');
                
                // 定義済み座標系を登録
                Object.keys(crsDefinitions).forEach(epsg => {
                    const projString = crsDefinitions[epsg];
                    proj4.defs(`EPSG:${epsg}`, projString);
                    console.log(`座標系定義登録: EPSG:${epsg}`);
                });
                
                console.log('Proj4js初期化完了');
            } catch (error) {
                console.error('Proj4js初期化エラー:', error);
            }
        };
        
        // DOM要素の取得
        const dropOverlay = document.getElementById('dropOverlay');
        const fileInput = document.getElementById('fileInput');
        const fileInputContainer = document.getElementById('fileInputContainer');
        const fileInputClose = document.getElementById('fileInputClose');
        const controls = document.getElementById('controls');
        const controlsClose = document.getElementById('controlsClose');
        const basemapControls = document.getElementById('basemapControls');
        const basemapClose = document.getElementById('basemapClose');
        const basemapSelect = document.getElementById('basemapSelect');
        const basemapOpacity = document.getElementById('basemapOpacity');
        const opacityValue = document.getElementById('opacityValue');
        const fieldSelect = document.getElementById('fieldSelect');
        const featureCount = document.getElementById('featureCount');
        const status = document.getElementById('status');
        const heatmapMode = document.getElementById('heatmapMode');
        const labelMode = document.getElementById('labelMode');
        const colorLegend = document.getElementById('colorLegend');
        const legendContent = document.getElementById('legendContent');
        const fieldInfo = document.getElementById('fieldInfo');
        const lineWidth = document.getElementById('lineWidth');
        const lineWidthValue = document.getElementById('lineWidthValue');
        
        // GeoTIFF関連のDOM要素
        const geotiffControls = document.getElementById('geotiffControls');
        const geotiffClose = document.getElementById('geotiffClose');
        const geotiffInput = document.getElementById('geotiffInput');
        const geotiffOpacity = document.getElementById('geotiffOpacity');
        const geotiffOpacityValue = document.getElementById('geotiffOpacityValue');
        const geotiffStatus = document.getElementById('geotiffStatus');
        const geotiffRemove = document.getElementById('geotiffRemove');
        
        // 計測関連のDOM要素
        const measureControls = document.getElementById('measureControls');
        const measureClose = document.getElementById('measureClose');
        const measureDistance = document.getElementById('measureDistance');
        const measureArea = document.getElementById('measureArea');
        const measureResult = document.getElementById('measureResult');
        const measureClear = document.getElementById('measureClear');
        
        // 座標系変換関連のDOM要素
        crsDialogOverlay = document.getElementById('crsDialogOverlay');
        const crsCancel = document.getElementById('crsCancel');
        const crsConvert = document.getElementById('crsConvert');
        const jgd2011Zone = document.getElementById('jgd2011Zone');
        
        // パネルの最小化/復元機能
        fileInputClose.addEventListener('click', (e) => {
            e.stopPropagation();
            fileInputContainer.classList.add('minimized');
            setTimeout(adjustPanelPositions, 100);
        });
        
        fileInputContainer.addEventListener('click', (e) => {
            if (fileInputContainer.classList.contains('minimized')) {
                e.stopPropagation();
                fileInputContainer.classList.remove('minimized');
                setTimeout(adjustPanelPositions, 100);
            }
        });
        
        controlsClose.addEventListener('click', (e) => {
            e.stopPropagation();
            controls.classList.add('minimized');
            setTimeout(adjustPanelPositions, 100);
        });
        
        controls.addEventListener('click', (e) => {
            if (controls.classList.contains('minimized')) {
                e.stopPropagation();
                controls.classList.remove('minimized');
                setTimeout(adjustPanelPositions, 100);
            }
        });
        
        // 背景地図パネルの最小化/復元機能
        basemapClose.addEventListener('click', (e) => {
            e.stopPropagation();
            basemapControls.classList.add('minimized');
        });
        
        basemapControls.addEventListener('click', (e) => {
            if (basemapControls.classList.contains('minimized')) {
                e.stopPropagation();
                basemapControls.classList.remove('minimized');
            }
        });
        
        // GeoTIFFパネルの最小化/復元機能
        geotiffClose.addEventListener('click', (e) => {
            e.stopPropagation();
            geotiffControls.classList.add('minimized');
            setTimeout(adjustPanelPositions, 100);
        });
        
        geotiffControls.addEventListener('click', (e) => {
            if (geotiffControls.classList.contains('minimized')) {
                e.stopPropagation();
                geotiffControls.classList.remove('minimized');
                setTimeout(adjustPanelPositions, 100);
            }
        });
        
        // 計測パネルの最小化/復元機能
        measureClose.addEventListener('click', (e) => {
            e.stopPropagation();
            measureControls.classList.add('minimized');
            setTimeout(adjustPanelPositions, 100);
        });
        
        measureControls.addEventListener('click', (e) => {
            if (measureControls.classList.contains('minimized')) {
                e.stopPropagation();
                measureControls.classList.remove('minimized');
                setTimeout(adjustPanelPositions, 100);
            }
        });
        
        // ウィンドウ全体でのドラッグ&ドロップイベント
        let dragCounter = 0;
        
        window.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            if (dragCounter === 1) {
                dropOverlay.classList.add('active');
            }
        });
        
        window.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dropOverlay.classList.remove('active');
            }
        });
        
        window.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        
        window.addEventListener('drop', (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropOverlay.classList.remove('active');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const fileName = file.name.toLowerCase();
                
                if (fileName.endsWith('.tif') || fileName.endsWith('.tiff')) {
                    handleGeoTIFFFile(file);
                } else {
                    handleFile(file);
                }
            }
        });
        
        // ファイル選択イベント
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        // フィールド選択イベント
        fieldSelect.addEventListener('change', (e) => {
            currentField = e.target.value;
            if (currentField && currentGeoJSON) {
                analyzeField();
                updateVisualization();
            } else {
                clearVisualization();
            }
        });
        
        // ヒートマップモード切り替えイベント
        heatmapMode.addEventListener('change', (e) => {
            isHeatmapMode = e.target.checked;
            if (currentField && currentGeoJSON) {
                updateVisualization();
            }
        });
        
        // ラベルモード切り替えイベント
        labelMode.addEventListener('change', (e) => {
            isLabelMode = e.target.checked;
            if (currentField && currentGeoJSON) {
                updateVisualization();
            }
        });
        
        // 背景地図切り替えイベント
        basemapSelect.addEventListener('change', (e) => {
            currentBasemap = e.target.value;
            changeBasemap(currentBasemap);
        });
        
        // 背景地図透明度切り替えイベント
        basemapOpacity.addEventListener('input', (e) => {
            const opacity = parseInt(e.target.value) / 100;
            opacityValue.textContent = e.target.value + '%';
            
            if (map.getLayer('basemap')) {
                map.setPaintProperty('basemap', 'raster-opacity', opacity);
            }
        });
        
        // ライン幅調整イベント
        lineWidth.addEventListener('input', (e) => {
            const width = parseFloat(e.target.value);
            lineWidthValue.textContent = width.toFixed(1);
            
            if (map.getLayer('geojson-line')) {
                map.setPaintProperty('geojson-line', 'line-width', width);
            }
        });
        
        // GeoTIFFファイル選択イベント
        geotiffInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleGeoTIFFFile(e.target.files[0]);
            }
        });
        
        // GeoTIFF透明度調整イベント
        geotiffOpacity.addEventListener('input', (e) => {
            const opacity = parseInt(e.target.value) / 100;
            geotiffOpacityValue.textContent = e.target.value + '%';
            
            if (map.getSource('geotiff')) {
                map.setPaintProperty('geotiff-layer', 'raster-opacity', opacity);
            }
        });
        
        // GeoTIFF削除イベント
        geotiffRemove.addEventListener('click', () => {
            removeGeoTIFF();
        });
        
        // 計測機能イベント
        measureDistance.addEventListener('click', () => {
            startMeasure('distance');
        });
        
        measureArea.addEventListener('click', () => {
            startMeasure('area');
        });
        
        measureClear.addEventListener('click', () => {
            clearMeasurements();
        });
        
        // ESCキーで計測終了
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && measureMode) {
                clearMeasurements();
            }
        });
        
        // 座標系変換ダイアログのイベント
        crsCancel.addEventListener('click', () => {
            hideCRSDialog();
        });
        
        crsConvert.addEventListener('click', async () => {
            const button = document.getElementById('crsConvert');
            
            // ボタンが既に無効化されている場合は処理しない
            if (button.disabled) {
                return;
            }
            
            // ボタンを無効化
            setConvertButtonState(true);
            
            try {
                await handleCRSConversion();
            } catch (error) {
                console.error('変換処理エラー:', error);
            } finally {
                // 処理完了後にボタンを有効化
                setConvertButtonState(false);
            }
        });
        
        // JGD2011選択時の処理
        document.querySelector('input[value="jgd2011"]').addEventListener('change', (e) => {
            if (e.target.checked) {
                jgd2011Zone.focus();
            }
        });
        
        // ファイル処理関数
        function handleFile(file) {
            if (!file.name.toLowerCase().endsWith('.geojson') && !file.name.toLowerCase().endsWith('.json')) {
                showStatus('GeoJSONファイル（.geojson または .json）を選択してください', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const geoJSON = JSON.parse(e.target.result);
                    
                    // 座標系チェック
                    if (!isWGS84Compatible(geoJSON)) {
                        // WGS84ではない可能性がある場合はダイアログを表示
                        pendingGeoJSON = geoJSON;
                        showCRSDialog();
                    } else {
                        // WGS84互換の場合はそのまま読み込み
                        loadGeoJSON(geoJSON);
                        showStatus('GeoJSONファイルが正常に読み込まれました', 'success');
                    }
                } catch (error) {
                    showStatus('ファイルの解析エラー: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }
        
        // 座標系がWGS84互換かチェックする関数
        function isWGS84Compatible(geoJSON) {
            if (!geoJSON.features || geoJSON.features.length === 0) {
                return true; // データがない場合はWGS84として扱う
            }
            
            // CRSプロパティをチェック
            if (geoJSON.crs && geoJSON.crs.properties && geoJSON.crs.properties.name) {
                const crsName = geoJSON.crs.properties.name.toLowerCase();
                if (crsName.includes('epsg:4326') || crsName.includes('wgs84')) {
                    return true;
                }
                if (crsName.includes('epsg:') && !crsName.includes('epsg:4326')) {
                    return false; // 4326以外のEPSGコードが明示されている
                }
            }
            
            // 座標値の範囲をチェック（WGS84は経度-180~180、緯度-90~90）
            let suspiciousCount = 0;
            let totalPoints = 0;
            
            function checkCoordinates(coords) {
                if (Array.isArray(coords[0])) {
                    // 多次元配列の場合は再帰的にチェック
                    coords.forEach(checkCoordinates);
                } else {
                    // 座標点の場合
                    const [lng, lat] = coords;
                    totalPoints++;
                    
                    // WGS84の範囲外かチェック
                    if (lng < -180 || lng > 180 || lat < -90 || lat > 90) {
                        suspiciousCount++;
                    }
                    
                    // 日本の座標系っぽい値かチェック（大きな座標値）
                    if (Math.abs(lng) > 1000 || Math.abs(lat) > 1000) {
                        suspiciousCount++;
                    }
                }
            }
            
            // 最初のいくつかのフィーチャをサンプリング
            const sampleSize = Math.min(geoJSON.features.length, 10);
            for (let i = 0; i < sampleSize; i++) {
                const feature = geoJSON.features[i];
                if (feature.geometry && feature.geometry.coordinates) {
                    checkCoordinates(feature.geometry.coordinates);
                }
            }
            
            // 疑わしい座標が50%以上ある場合はWGS84ではないと判定
            if (totalPoints > 0 && suspiciousCount / totalPoints > 0.5) {
                return false;
            }
            
            return true;
        }
        
        // GeoTIFFの座標系チェック関数
        async function checkGeoTIFFCRS(geoKeys, image) {
            try {
                console.log('GeoTIFF GeoKeys:', geoKeys);
                
                // EPSGコードをチェック
                let epsgCode = null;
                if (geoKeys.ProjectedCSTypeGeoKey) {
                    epsgCode = geoKeys.ProjectedCSTypeGeoKey;
                    console.log('ProjectedCSTypeGeoKey:', epsgCode);
                } else if (geoKeys.GeographicTypeGeoKey) {
                    epsgCode = geoKeys.GeographicTypeGeoKey;
                    console.log('GeographicTypeGeoKey:', epsgCode);
                }
                
                // WGS84 (4326) かチェック
                if (epsgCode === 4326) {
                    console.log('WGS84として判定');
                    return true;
                }
                
                // JGD2011系 (6675-6679など) かチェック
                if (epsgCode >= 6675 && epsgCode <= 6679) {
                    console.log('JGD2011系として判定:', epsgCode);
                    return false; // 変換が必要
                }
                
                // その他の投影座標系
                if (epsgCode && epsgCode !== 4326) {
                    console.log('その他の投影座標系として判定:', epsgCode);
                    return false; // 変換が必要
                }
                
                // 座標範囲をチェック
                const bbox = image.getBoundingBox();
                console.log('GeoTIFF bbox:', bbox);
                
                if (bbox) {
                    const [minX, minY, maxX, maxY] = bbox;
                    
                    // WGS84の範囲外かチェック
                    if (minX < -180 || maxX > 180 || minY < -90 || maxY > 90) {
                        console.log('WGS84範囲外として判定');
                        return false; // 変換が必要
                    }
                    
                    // 日本の投影座標系っぽい大きな値かチェック
                    if (Math.abs(minX) > 1000 || Math.abs(maxX) > 1000 || 
                        Math.abs(minY) > 1000 || Math.abs(maxY) > 1000) {
                        console.log('投影座標系として判定（大きな座標値）');
                        return false; // 変換が必要
                    }
                }
                
                console.log('WGS84として判定（デフォルト）');
                return true; // WGS84と推定
            } catch (error) {
                console.warn('GeoTIFF座標系チェックエラー:', error);
                return true; // エラーの場合はWGS84として扱う
            }
        }
        
        // 座標系変換ダイアログを表示
        function showCRSDialog(type = 'geojson') {
            currentDialogType = type;
            
            // ダイアログのタイトルを更新
            const dialogHeader = crsDialogOverlay.querySelector('.crs-dialog-header h3');
            if (type === 'geotiff') {
                dialogHeader.textContent = 'GeoTIFF座標系変換';
                
                // メッセージも更新
                const messages = crsDialogOverlay.querySelectorAll('.crs-dialog-content p');
                messages[0].textContent = 'このGeoTIFFファイルはWGS84座標系ではない可能性があります。';
                messages[1].textContent = 'データの測地系を指定してください。';
            } else {
                dialogHeader.textContent = '座標系変換';
                
                // メッセージを元に戻す
                const messages = crsDialogOverlay.querySelectorAll('.crs-dialog-content p');
                messages[0].textContent = 'このGeoJSONデータはWGS84座標系ではない可能性があります。';
                messages[1].textContent = 'データの測地系を指定してください。';
            }
            
            crsDialogOverlay.style.display = 'flex';
        }
        
        // 座標系変換ダイアログを非表示
        function hideCRSDialog() {
            crsDialogOverlay.style.display = 'none';
            pendingGeoJSON = null;
            pendingGeoTIFF = null;
            currentDialogType = 'geojson';
        }
        
        // 変換ボタンの状態管理
        function setConvertButtonState(isLoading) {
            const button = document.getElementById('crsConvert');
            const originalText = '変換して読み込み';
            
            if (isLoading) {
                button.disabled = true;
                button.innerHTML = `
                    <span style="display: inline-flex; align-items: center;">
                        <svg style="animation: spin 1s linear infinite; width: 16px; height: 16px; margin-right: 8px;" viewBox="0 0 24 24" fill="none">
                            <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" stroke-dasharray="31.416" stroke-dashoffset="31.416" opacity="0.3"/>
                            <path d="M12 2C6.477 2 2 6.477 2 12" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
                        </svg>
                        変換中...
                    </span>
                `;
                button.style.backgroundColor = '#6c757d';
                button.style.cursor = 'not-allowed';
                button.style.opacity = '0.7';
            } else {
                button.disabled = false;
                button.innerHTML = originalText;
                button.style.backgroundColor = '';
                button.style.cursor = '';
                button.style.opacity = '';
            }
        }
        
        // 座標系変換を実行
        async function handleCRSConversion() {
            if (!pendingGeoJSON && !pendingGeoTIFF) return;
            
            // JGD2011のドロップダウンから系を選択
            const sourceEpsg = jgd2011Zone.value;
            
            try {
                if (currentDialogType === 'geotiff' && pendingGeoTIFF) {
                    // GeoTIFFの座標系変換
                    await handleGeoTIFFConversion(sourceEpsg);
                } else if (pendingGeoJSON) {
                    // GeoJSONの座標系変換
                    const convertedGeoJSON = convertCRS(pendingGeoJSON, sourceEpsg, '4326');
                    loadGeoJSON(convertedGeoJSON);
                    
                    // 変換完了メッセージに系の名前を含める
                    const zoneName = getZoneName(sourceEpsg);
                    showStatus(`座標系変換完了 (${zoneName} → WGS84)`, 'success');
                }
                
                hideCRSDialog();
            } catch (error) {
                console.error('座標系変換エラー:', error);
                alert('座標系変換に失敗しました: ' + error.message);
            }
        }
        
        // 座標系の名前を取得
        function getZoneName(epsgCode) {
            const zoneNames = {
                '6675': 'JGD2011 7系',
                '6676': 'JGD2011 8系', 
                '6677': 'JGD2011 9系',
                '6678': 'JGD2011 10系',
                '6679': 'JGD2011 11系'
            };
            return zoneNames[epsgCode] || `EPSG:${epsgCode}`;
        }
        
        // GeoTIFFの座標系変換処理
        async function handleGeoTIFFConversion(sourceEpsg) {
            if (!pendingGeoTIFF) return;
            
            try {
                showGeoTIFFStatus('GeoTIFFファイルを解析中...', 'info');
                console.log('GeoTIFF座標系変換開始:', sourceEpsg);
                
                // 元のGeoTIFFを読み込み
                const tiff = await GeoTIFF.fromArrayBuffer(pendingGeoTIFF.arrayBuffer);
                const image = await tiff.getImage();
                const originalBbox = image.getBoundingBox();
                console.log('元のbbox:', originalBbox);
                
                showGeoTIFFStatus('座標系変換を実行中...', 'info');
                
                // 座標変換
                const convertedBbox = await convertGeoTIFFBbox(originalBbox, sourceEpsg, '4326');
                console.log('変換後のbbox:', convertedBbox);
                
                showGeoTIFFStatus('GeoTIFFをマップに読み込み中...', 'info');
                
                // 変換後のGeoTIFFを読み込み
                await loadGeoTIFF(pendingGeoTIFF.arrayBuffer, convertedBbox);
                
                const zoneName = getZoneName(sourceEpsg);
                showGeoTIFFStatus(`GeoTIFF座標系変換完了 (${zoneName} → WGS84)`, 'success');
                
            } catch (error) {
                console.error('GeoTIFF座標系変換エラー詳細:', error);
                showGeoTIFFStatus('GeoTIFF座標系変換に失敗しました: ' + error.message, 'error');
                throw error;
            }
        }
        
        // GeoTIFFのbbox変換（改良版）
        async function convertGeoTIFFBbox(originalBbox, sourceEpsg, targetEpsg) {
            try {
                // Proj4jsで投影変換を定義
                const sourceProj = `EPSG:${sourceEpsg}`;
                const targetProj = `EPSG:${targetEpsg}`;
                
                console.log('変換:', sourceProj, '→', targetProj);
                
                // カスタムEPSGコードの場合、定義が必要
                if (!proj4.defs(sourceProj)) {
                    if (crsDefinitions[sourceEpsg]) {
                        proj4.defs(sourceProj, crsDefinitions[sourceEpsg]);
                        console.log('座標系定義を登録:', sourceProj);
                    } else {
                        throw new Error(`EPSG:${sourceEpsg} の座標系定義が見つかりません`);
                    }
                }
                
                // 4隅の座標を変換
                const [minX, minY, maxX, maxY] = originalBbox;
                const corners = [
                    [minX, minY], // 左下
                    [maxX, minY], // 右下
                    [maxX, maxY], // 右上
                    [minX, maxY]  // 左上
                ];
                
                console.log('変換前の角座標:', corners);
                
                const transformedCorners = corners.map(corner => {
                    const transformed = proj4(sourceProj, targetProj, corner);
                    console.log(`${corner} → ${transformed}`);
                    return transformed;
                });
                
                // 変換後のbboxを計算
                const transformedBbox = [
                    Math.min(...transformedCorners.map(c => c[0])), // minX
                    Math.min(...transformedCorners.map(c => c[1])), // minY
                    Math.max(...transformedCorners.map(c => c[0])), // maxX
                    Math.max(...transformedCorners.map(c => c[1]))  // maxY
                ];
                
                console.log('変換後のbbox:', transformedBbox);
                
                // 結果の妥当性チェック
                if (transformedBbox.some(val => !isFinite(val))) {
                    throw new Error('座標変換結果が無効です');
                }
                
                return transformedBbox;
                
            } catch (error) {
                console.error('Bbox変換エラー:', error);
                throw new Error(`座標変換に失敗しました: ${error.message}`);
            }
        }
        
        // 座標系変換関数
        function convertCRS(geoJSON, sourceEpsg, targetEpsg) {
            // Proj4jsで投影変換を定義
            const sourceProj = `EPSG:${sourceEpsg}`;
            const targetProj = `EPSG:${targetEpsg}`;
            
            // カスタムEPSGコードの場合、定義が必要
            if (!proj4.defs(sourceProj)) {
                if (crsDefinitions[sourceEpsg]) {
                    proj4.defs(sourceProj, crsDefinitions[sourceEpsg]);
                } else {
                    throw new Error(`EPSG:${sourceEpsg} の座標系定義が見つかりません`);
                }
            }
            
            // GeoJSONをコピー
            const convertedGeoJSON = JSON.parse(JSON.stringify(geoJSON));
            
            // 座標変換関数
            function transformCoordinates(coords) {
                if (Array.isArray(coords[0])) {
                    // 多次元配列の場合は再帰的に変換
                    return coords.map(transformCoordinates);
                } else {
                    // 座標点の場合は変換
                    const [x, y] = coords;
                    const transformed = proj4(sourceProj, targetProj, [x, y]);
                    return [transformed[0], transformed[1]];
                }
            }
            
            // 全フィーチャの座標を変換
            convertedGeoJSON.features.forEach(feature => {
                if (feature.geometry && feature.geometry.coordinates) {
                    feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                }
            });
            
            // CRSプロパティを更新
            convertedGeoJSON.crs = {
                type: "name",
                properties: {
                    name: "EPSG:4326"
                }
            };
            
            return convertedGeoJSON;
        }
        
        // GeoTIFFファイル処理関数
        function handleGeoTIFFFile(file) {
            if (!file.name.toLowerCase().endsWith('.tif') && !file.name.toLowerCase().endsWith('.tiff')) {
                showGeoTIFFStatus('GeoTIFFファイル（.tif または .tiff）を選択してください', 'error');
                return;
            }
            
            showGeoTIFFStatus('GeoTIFFファイルを読み込み中...', 'info');
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    
                    // GeoTIFFの座標系をチェック
                    const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
                    const image = await tiff.getImage();
                    
                    // GeoTIFFのCRS情報を取得
                    const geoKeys = image.getGeoKeys();
                    const isWGS84 = await checkGeoTIFFCRS(geoKeys, image);
                    
                    if (!isWGS84) {
                        // WGS84ではない場合はダイアログを表示
                        pendingGeoTIFF = { arrayBuffer, file };
                        showCRSDialog('geotiff');
                    } else {
                        // WGS84の場合はそのまま読み込み
                        await loadGeoTIFF(arrayBuffer);
                        showGeoTIFFStatus('GeoTIFFファイルが正常に読み込まれました', 'success');
                    }
                } catch (error) {
                    console.error('GeoTIFF読み込みエラー:', error);
                    showGeoTIFFStatus('GeoTIFFファイルの読み込みエラー: ' + error.message, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // GeoTIFF読み込み関数
        async function loadGeoTIFF(arrayBuffer, customBbox = null) {
            try {
                // 既存のGeoTIFFレイヤーを削除
                removeGeoTIFF();
                
                // ファイルサイズをチェック
                const fileSizeMB = arrayBuffer.byteLength / (1024 * 1024);
                console.log(`GeoTIFFファイルサイズ: ${fileSizeMB.toFixed(2)} MB`);
                
                if (fileSizeMB > 50) {
                    throw new Error(`ファイルサイズが大きすぎます (${fileSizeMB.toFixed(1)}MB)。50MB以下のファイルを使用してください。`);
                }
                
                // GeoTIFFを解析
                const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
                const image = await tiff.getImage();
                
                // 画像サイズを取得
                const width = image.getWidth();
                const height = image.getHeight();
                const pixelCount = width * height;
                
                console.log(`画像サイズ: ${width}x${height} (${(pixelCount / 1000000).toFixed(1)}M pixels)`);
                
                // 大きすぎる画像をチェック
                if (pixelCount > 10000000) { // 10M pixels
                    throw new Error(`画像サイズが大きすぎます (${width}x${height})。より小さな解像度の画像を使用してください。`);
                }
                
                // 地理情報を取得
                const bbox = customBbox || image.getBoundingBox();
                
                // リサンプリングサイズを決定（最大2048x2048）
                const maxSize = 2048;
                let displayWidth = width;
                let displayHeight = height;
                
                if (width > maxSize || height > maxSize) {
                    const scale = Math.min(maxSize / width, maxSize / height);
                    displayWidth = Math.floor(width * scale);
                    displayHeight = Math.floor(height * scale);
                    console.log(`リサンプリング: ${width}x${height} → ${displayWidth}x${displayHeight}`);
                }
                
                // ラスターデータを読み込み（リサンプリング）
                const rasters = await image.readRasters({
                    width: displayWidth,
                    height: displayHeight,
                    resampleMethod: 'bilinear'
                });
                
                // Canvasを作成
                const canvas = document.createElement('canvas');
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                const ctx = canvas.getContext('2d');
                
                // ImageDataを作成
                const imageData = ctx.createImageData(displayWidth, displayHeight);
                const data = imageData.data;
                
                // RGBまたは単一バンドの処理
                const chunkSize = 10000;
                
                if (rasters.length >= 3) {
                    // RGBデータの場合
                    const redBand = rasters[0];
                    const greenBand = rasters[1];
                    const blueBand = rasters[2];
                    
                    for (let i = 0; i < redBand.length; i += chunkSize) {
                        const endIndex = Math.min(i + chunkSize, redBand.length);
                        
                        for (let j = i; j < endIndex; j++) {
                            const pixelIndex = j * 4;
                            
                            // RGBデータをそのまま使用
                            data[pixelIndex] = redBand[j] || 0;     // R
                            data[pixelIndex + 1] = greenBand[j] || 0; // G
                            data[pixelIndex + 2] = blueBand[j] || 0;  // B
                            data[pixelIndex + 3] = 255;              // A
                        }
                        
                        // UIをブロックしないように少し待機
                        if (i % (chunkSize * 5) === 0) {
                            showGeoTIFFStatus(`処理中... ${Math.round((i / redBand.length) * 100)}%`, 'info');
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    }
                } else {
                    // 単一バンドの場合はグレースケール
                    const raster = rasters[0];
                    
                    for (let i = 0; i < raster.length; i += chunkSize) {
                        const endIndex = Math.min(i + chunkSize, raster.length);
                        
                        for (let j = i; j < endIndex; j++) {
                            const value = raster[j];
                            const pixelIndex = j * 4;
                            
                            if (value !== null && value !== undefined && !isNaN(value)) {
                                // 値をグレースケール（0-255）に正規化
                                const gray = Math.max(0, Math.min(255, value));
                                data[pixelIndex] = gray;     // R
                                data[pixelIndex + 1] = gray; // G
                                data[pixelIndex + 2] = gray; // B
                                data[pixelIndex + 3] = 255;  // A
                            } else {
                                // 無効な値は透明にする
                                data[pixelIndex] = 0;
                                data[pixelIndex + 1] = 0;
                                data[pixelIndex + 2] = 0;
                                data[pixelIndex + 3] = 0;
                            }
                        }
                        
                        // UIをブロックしないように少し待機
                        if (i % (chunkSize * 5) === 0) {
                            showGeoTIFFStatus(`処理中... ${Math.round((i / raster.length) * 100)}%`, 'info');
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                geotiffCanvas = canvas;
                
                // MapLibre GLにソースとして追加
                map.addSource('geotiff', {
                    type: 'canvas',
                    canvas: canvas,
                    coordinates: [
                        [bbox[0], bbox[3]], // 左上
                        [bbox[2], bbox[3]], // 右上
                        [bbox[2], bbox[1]], // 右下
                        [bbox[0], bbox[1]]  // 左下
                    ]
                });
                
                // レイヤーを追加（GeoJSONレイヤーの下に配置）
                const beforeLayer = map.getLayer('geojson-fill') ? 'geojson-fill' : undefined;
                map.addLayer({
                    id: 'geotiff-layer',
                    type: 'raster',
                    source: 'geotiff',
                    paint: {
                        'raster-opacity': parseInt(geotiffOpacity.value) / 100
                    }
                }, beforeLayer);
                
                currentGeoTIFF = { tiff, image, bbox };
                geotiffRemove.style.display = 'block';
                
                // マップをGeoTIFFの範囲に合わせる
                fitMapToGeoTIFF(bbox);
                
                // GeoTIFFコントロールパネルを展開
                geotiffControls.classList.remove('minimized');
                setTimeout(adjustPanelPositions, 100);
                
                console.log('GeoTIFF読み込み完了:', {
                    originalSize: `${width}x${height}`,
                    displaySize: `${displayWidth}x${displayHeight}`,
                    bbox: bbox,
                    bands: rasters.length
                });
                
            } catch (error) {
                console.error('GeoTIFF処理エラー:', error);
                throw error;
            }
        }
        
        // GeoTIFFをCanvasに描画する関数
        // GeoTIFF削除関数
        function removeGeoTIFF() {
            if (map.getLayer('geotiff-layer')) {
                map.removeLayer('geotiff-layer');
            }
            if (map.getSource('geotiff')) {
                map.removeSource('geotiff');
            }
            
            currentGeoTIFF = null;
            geotiffCanvas = null;
            geotiffRemove.style.display = 'none';
            geotiffStatus.style.display = 'none';
            geotiffInput.value = '';
            
            // GeoTIFFコントロールパネルを最小化
            geotiffControls.classList.add('minimized');
            setTimeout(adjustPanelPositions, 100);
        }
        
        // GeoTIFFステータス表示関数
        function showGeoTIFFStatus(message, type) {
            geotiffStatus.textContent = message;
            geotiffStatus.className = `geotiff-status ${type}`;
            geotiffStatus.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    geotiffStatus.style.display = 'none';
                }, 3000);
            } else if (type === 'info') {
                // info メッセージは手動で消すか、次のメッセージまで表示
            }
        }
        
        // 背景地図変更関数
        function changeBasemap(basemapType) {
            if (!basemapStyles[basemapType]) {
                console.error('Unknown basemap type:', basemapType);
                return;
            }
            
            // 現在のGeoJSONデータを保存
            const savedGeoJSON = currentGeoJSON;
            const savedField = currentField;
            const savedHeatmapMode = isHeatmapMode;
            const savedLabelMode = isLabelMode;
            
            // マップスタイルを変更
            map.setStyle(basemapStyles[basemapType]);
            
            // スタイル変更完了後にGeoJSONレイヤーを再構築
            map.once('styledata', () => {
                if (savedGeoJSON) {
                    // GeoJSONデータを再追加
                    map.addSource('geojson', {
                        'type': 'geojson',
                        'data': savedGeoJSON
                    });
                    
                    // レイヤーを再構築
                    map.addLayer({
                        'id': 'geojson-fill',
                        'type': 'fill',
                        'source': 'geojson',
                        'paint': {
                            'fill-color': '#088',
                            'fill-opacity': 0.5
                        }
                    });
                    
                    map.addLayer({
                        'id': 'geojson-line',
                        'type': 'line',
                        'source': 'geojson',
                        'paint': {
                            'line-color': '#088',
                            'line-width': parseFloat(lineWidth.value)
                        }
                    });
                    
                    // 表示設定を復元
                    currentField = savedField;
                    isHeatmapMode = savedHeatmapMode;
                    isLabelMode = savedLabelMode;
                    
                    // フィールド選択を復元
                    if (currentField) {
                        fieldSelect.value = currentField;
                        analyzeField();
                        updateVisualization();
                    }
                }
                
                // GeoTIFFレイヤーを再構築
                if (currentGeoTIFF && geotiffCanvas) {
                    map.addSource('geotiff', {
                        type: 'canvas',
                        canvas: geotiffCanvas,
                        coordinates: [
                            [currentGeoTIFF.bbox[0], currentGeoTIFF.bbox[3]], // 左上
                            [currentGeoTIFF.bbox[2], currentGeoTIFF.bbox[3]], // 右上
                            [currentGeoTIFF.bbox[2], currentGeoTIFF.bbox[1]], // 右下
                            [currentGeoTIFF.bbox[0], currentGeoTIFF.bbox[1]]  // 左下
                        ]
                    });
                    
                    const beforeLayer = map.getLayer('geojson-fill') ? 'geojson-fill' : undefined;
                    map.addLayer({
                        id: 'geotiff-layer',
                        type: 'raster',
                        source: 'geotiff',
                        paint: {
                            'raster-opacity': parseInt(geotiffOpacity.value) / 100
                        }
                    }, beforeLayer);
                }
                
                // 背景地図の透明度を適用
                const opacity = parseInt(basemapOpacity.value) / 100;
                if (map.getLayer('basemap')) {
                    map.setPaintProperty('basemap', 'raster-opacity', opacity);
                }
            });
        }
        
        // GeoJSON読み込み関数
        function loadGeoJSON(geoJSON) {
            // レイヤーIDを生成
            geoJSONLayerCounter++;
            const layerId = isFirstGeoJSON ? 'geojson' : `geojson-${geoJSONLayerCounter}`;
            
            // 最初のGeoJSONの場合のみ、現在のGeoJSONとして管理
            if (isFirstGeoJSON) {
                currentGeoJSON = geoJSON;
                isFirstGeoJSON = false;
                
                // 既存のGeoJSONレイヤーを削除（初回のみ）
                if (map.getSource('geojson')) {
                    // Fill レイヤーの削除
                    if (map.getLayer('geojson-fill')) {
                        map.removeLayer('geojson-fill');
                    }
                    // Line レイヤーの削除
                    if (map.getLayer('geojson-line')) {
                        map.removeLayer('geojson-line');
                    }
                    // Circle レイヤーの削除
                    if (map.getLayer('geojson-circle')) {
                        map.removeLayer('geojson-circle');
                    }
                    // Symbol レイヤーの削除
                    if (map.getLayer('geojson-symbol')) {
                        map.removeLayer('geojson-symbol');
                    }
                    // Heatmap レイヤーの削除
                    if (map.getLayer('geojson-heatmap')) {
                        map.removeLayer('geojson-heatmap');
                    }
                    map.removeSource('geojson');
                }
            }
            
            // 新しいソースを追加
            map.addSource(layerId, {
                'type': 'geojson',
                'data': geoJSON
            });
            
            // ジオメトリタイプを判定
            const geometryTypes = new Set();
            if (geoJSON.features) {
                geoJSON.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.type) {
                        geometryTypes.add(feature.geometry.type);
                    }
                });
            }
            
            // ジオメトリタイプ別の色設定
            const getColors = () => {
                if (layerId === 'geojson') {
                    // 最初のレイヤーは従来の色
                    return {
                        polygon: '#088',
                        line: '#088',
                        point: '#088'
                    };
                } else {
                    // 追加レイヤーはジオメトリタイプ別に色分け
                    return {
                        polygon: '#088', // ポリゴンは従来通り
                        line: '#2196f3', // 青系
                        point: '#f44336' // 赤系
                    };
                }
            };
            
            const colors = getColors();
            
            // ジオメトリタイプに応じてレイヤーを追加
            // ポリゴンまたはマルチポリゴンが含まれている場合、塗りつぶしレイヤーを追加
            if (geometryTypes.has('Polygon') || geometryTypes.has('MultiPolygon')) {
                map.addLayer({
                    'id': `${layerId}-fill`,
                    'type': 'fill',
                    'source': layerId,
                    'filter': ['in', ['geometry-type'], ['literal', ['Polygon', 'MultiPolygon']]],
                    'paint': {
                        'fill-color': colors.polygon,
                        'fill-opacity': 0.5
                    }
                });
            }
            
            // ライン、ポリゴン、マルチライン、マルチポリゴンが含まれている場合、ラインレイヤーを追加
            if (geometryTypes.has('LineString') || geometryTypes.has('MultiLineString') || 
                geometryTypes.has('Polygon') || geometryTypes.has('MultiPolygon')) {
                map.addLayer({
                    'id': `${layerId}-line`,
                    'type': 'line',
                    'source': layerId,
                    'filter': ['in', ['geometry-type'], ['literal', ['LineString', 'MultiLineString', 'Polygon', 'MultiPolygon']]],
                    'paint': {
                        'line-color': colors.line,
                        'line-width': parseFloat(lineWidth.value)
                    }
                });
            }
            
            // ポイントまたはマルチポイントが含まれている場合、ポイントレイヤーを追加
            if (geometryTypes.has('Point') || geometryTypes.has('MultiPoint')) {
                map.addLayer({
                    'id': `${layerId}-circle`,
                    'type': 'circle',
                    'source': layerId,
                    'filter': ['in', ['geometry-type'], ['literal', ['Point', 'MultiPoint']]],
                    'paint': {
                        'circle-color': colors.point,
                        'circle-radius': 6,
                        'circle-stroke-color': '#fff',
                        'circle-stroke-width': 2
                    }
                });
            }
            
            // 最初のGeoJSONの場合のみ、UI更新処理を実行
            if (layerId === 'geojson') {
                // ジオメトリタイプ情報を表示
                updateGeometryInfo(geometryTypes);
                
                // フィールド選択肢を更新
                updateFieldOptions();
                
                // コントロールパネルを表示・展開、GeoJSON選択パネルを最小化
                controls.style.display = 'block';
                controls.classList.remove('minimized');
                fileInputContainer.classList.add('minimized');
                
                // マップイベントを設定
                setupLayerEvents();
                
                setTimeout(adjustPanelPositions, 100);
            }
            
            // マップを GeoJSON の範囲に合わせる
            fitMapToGeoJSON(geoJSON);
        }
        
        // GeoJSONレイヤーを地図に追加する関数
        
        // ジオメトリタイプ情報更新関数
        function updateGeometryInfo(geometryTypes) {
            const geometryInfo = document.getElementById('geometryInfo');
            if (!geometryInfo) {
                // ジオメトリ情報表示要素を作成
                const infoDiv = document.getElementById('fieldInfo');
                const newDiv = document.createElement('div');
                newDiv.id = 'geometryInfo';
                newDiv.style.marginTop = '5px';
                infoDiv.parentNode.insertBefore(newDiv, infoDiv);
            }
            
            const typeNames = {
                'Point': 'ポイント',
                'MultiPoint': 'マルチポイント',
                'LineString': 'ライン',
                'MultiLineString': 'マルチライン',
                'Polygon': 'ポリゴン',
                'MultiPolygon': 'マルチポリゴン'
            };
            
            const typeList = Array.from(geometryTypes).map(type => typeNames[type] || type).join(', ');
            document.getElementById('geometryInfo').innerHTML = `ジオメトリ: ${typeList}`;
        }
        
        // フィールド選択肢更新関数
        function updateFieldOptions() {
            fieldSelect.innerHTML = '<option value="">選択してください</option>';
            
            if (!currentGeoJSON || !currentGeoJSON.features || currentGeoJSON.features.length === 0) return;
            
            // 全フィーチャのプロパティからフィールド一覧を取得
            const allFields = new Set();
            currentGeoJSON.features.forEach(feature => {
                if (feature.properties) {
                    Object.keys(feature.properties).forEach(key => allFields.add(key));
                }
            });
            
            Array.from(allFields).sort().forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                fieldSelect.appendChild(option);
            });
        }
        
        // フィールド分析関数
        function analyzeField() {
            if (!currentField || !currentGeoJSON) return;
            
            const values = [];
            let isNumeric = true;
            let isInteger = true;
            let numericValues = [];
            
            currentGeoJSON.features.forEach(feature => {
                const value = feature.properties[currentField];
                if (value !== null && value !== undefined && value !== '') {
                    values.push(value);
                    
                    // 数値判定
                    const numValue = parseFloat(value);
                    if (isNaN(value) || isNaN(numValue)) {
                        isNumeric = false;
                        isInteger = false;
                    } else {
                        numericValues.push(numValue);
                        // 整数判定
                        if (isInteger && !Number.isInteger(numValue)) {
                            isInteger = false;
                        }
                    }
                }
            });
            
            fieldStats = {
                isNumeric: isNumeric,
                isInteger: isInteger,
                values: values,
                numericValues: numericValues,
                uniqueCount: new Set(values).size
            };
            
            if (isNumeric && numericValues.length > 0) {
                fieldStats.min = Math.min(...numericValues);
                fieldStats.max = Math.max(...numericValues);
                fieldStats.avg = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
            }
            
            updateFieldInfo();
        }
        
        // フィールド情報更新関数
        function updateFieldInfo() {
            if (!fieldStats) {
                fieldInfo.textContent = '';
                return;
            }
            
            let dataType = 'テキスト';
            if (fieldStats.isNumeric) {
                dataType = fieldStats.isInteger ? '整数' : '小数';
            }
            
            let info = `タイプ: ${dataType}, `;
            info += `ユニーク値: ${fieldStats.uniqueCount}`;
            
            if (fieldStats.isNumeric) {
                const minDisplay = fieldStats.isInteger ? fieldStats.min.toString() : fieldStats.min.toFixed(2);
                const maxDisplay = fieldStats.isInteger ? fieldStats.max.toString() : fieldStats.max.toFixed(2);
                const avgDisplay = fieldStats.isInteger ? Math.round(fieldStats.avg).toString() : fieldStats.avg.toFixed(2);
                
                info += `<br>範囲: ${minDisplay} - ${maxDisplay}`;
                info += `<br>平均: ${avgDisplay}`;
                info += `<br>数値データ: ${fieldStats.numericValues.length}/${fieldStats.values.length}`;
            }
            
            fieldInfo.innerHTML = info;
            
            // ヒートマップモードのチェックボックス表示制御
            if (fieldStats.isNumeric && fieldStats.numericValues.length > 0) {
                heatmapMode.parentElement.style.display = 'block';
            } else {
                heatmapMode.parentElement.style.display = 'none';
                heatmapMode.checked = false;
                isHeatmapMode = false;
            }
        }
        
        // 可視化更新関数
        function updateVisualization() {
            // レイヤーの色をリセット
            if (map.getLayer('geojson-fill')) {
                map.setPaintProperty('geojson-fill', 'fill-color', '#088');
            }
            if (map.getLayer('geojson-line')) {
                map.setPaintProperty('geojson-line', 'line-color', '#088');
            }
            if (map.getLayer('geojson-point')) {
                map.setPaintProperty('geojson-point', 'circle-color', '#088');
            }
            
            // ヒートマップモードの処理
            if (isHeatmapMode && fieldStats && fieldStats.isNumeric) {
                updateHeatmap();
                colorLegend.style.display = 'block';
                updateColorLegend();
            } else {
                colorLegend.style.display = 'none';
            }
            
            // ラベルモードの処理（ヒートマップとは独立）
            if (isLabelMode) {
                updateLabels();
            } else {
                // ラベル非表示
                if (map.getLayer('geojson-labels')) {
                    map.removeLayer('geojson-labels');
                }
            }
        }
        
        // 可視化クリア関数
        function clearVisualization() {
            // ラベルレイヤーを削除
            if (map.getLayer('geojson-labels')) {
                map.removeLayer('geojson-labels');
            }
            
            // ポリゴンの色を元に戻す
            if (map.getLayer('geojson-fill')) {
                map.setPaintProperty('geojson-fill', 'fill-color', '#088');
            }
            
            colorLegend.style.display = 'none';
            fieldInfo.innerHTML = '';
        }
        
        // ヒートマップ更新関数
        function updateHeatmap() {
            if (!currentField || !currentGeoJSON || !fieldStats.isNumeric) return;
            
            // データ範囲に0が含まれるかチェック
            const includesZero = fieldStats.min <= 0 && fieldStats.max >= 0;
            
            if (includesZero) {
                // 0基準の色分け（プラス=赤系、マイナス=青系、ゼロ=白）
                console.log('0基準の色分けを適用:', fieldStats.min, 'から', fieldStats.max);
                
                // 色分け表現を直接構築
                const colorExpression = [
                    'case',
                    // 数値でない場合はデフォルト色（グレー）
                    ['!=', ['typeof', ['get', currentField]], 'number'],
                    '#cccccc',
                    // 数値の場合は interpolate で色分け
                    [
                        'interpolate',
                        ['linear'],
                        ['get', currentField]
                    ]
                ];
                
                // マイナス側の色分け点を追加
                if (fieldStats.min < 0) {
                    colorExpression[3].push(fieldStats.min, 'rgb(0,0,255)'); // 最小値=青
                    colorExpression[3].push(fieldStats.min * 0.5, 'rgb(128,128,255)'); // 中間=薄い青
                }
                
                // ゼロ点を追加
                colorExpression[3].push(0, 'rgb(255,255,255)'); // ゼロ=白
                
                // プラス側の色分け点を追加
                if (fieldStats.max > 0) {
                    colorExpression[3].push(fieldStats.max * 0.5, 'rgb(255,128,128)'); // 中間=薄い赤
                    colorExpression[3].push(fieldStats.max, 'rgb(255,0,0)'); // 最大値=赤
                }
                
                console.log('色分け表現:', colorExpression);
                
                // すべてのレイヤータイプに色分けを適用
                if (map.getLayer('geojson-fill')) {
                    map.setPaintProperty('geojson-fill', 'fill-color', colorExpression);
                }
                if (map.getLayer('geojson-line')) {
                    map.setPaintProperty('geojson-line', 'line-color', colorExpression);
                }
                if (map.getLayer('geojson-point')) {
                    map.setPaintProperty('geojson-point', 'circle-color', colorExpression);
                }
                
            } else {
                // 0を含まない場合：従来の最大最小基準
                console.log('従来の色分けを適用:', fieldStats.min, 'から', fieldStats.max);
                
                const colorExpression = [
                    'case',
                    // 数値でない場合はデフォルト色（グレー）
                    ['!=', ['typeof', ['get', currentField]], 'number'],
                    '#cccccc',
                    // 数値の場合は interpolate で色分け
                    [
                        'interpolate',
                        ['linear'],
                        ['get', currentField]
                    ]
                ];
                
                // 5段階の色分け
                const steps = 5;
                for (let i = 0; i <= steps; i++) {
                    const ratio = i / steps;
                    const value = fieldStats.min + (fieldStats.max - fieldStats.min) * ratio;
                    const color = getHeatmapColor(ratio);
                    colorExpression[3].push(value, color);
                }
                
                // すべてのレイヤータイプに色分けを適用
                if (map.getLayer('geojson-fill')) {
                    map.setPaintProperty('geojson-fill', 'fill-color', colorExpression);
                }
                if (map.getLayer('geojson-line')) {
                    map.setPaintProperty('geojson-line', 'line-color', colorExpression);
                }
                if (map.getLayer('geojson-point')) {
                    map.setPaintProperty('geojson-point', 'circle-color', colorExpression);
                }
            }
        }
        
        // 0基準のヒートマップ色取得関数
        function getZeroBasedHeatmapColor(value, positiveMax, negativeMin) {
            // 0付近は白色で表示
            if (Math.abs(value) <= 0.1) {
                return 'rgb(255,255,255)'; // 白
            }
            
            if (value > 0 && positiveMax > 0) {
                // プラス側：白→赤系のグラデーション
                const intensity = Math.min(value / positiveMax, 1.0);
                
                if (intensity <= 0.5) {
                    // 白 → 薄いピンク
                    const factor = intensity * 2;
                    const red = 255;
                    const green = Math.round(255 * (1 - factor * 0.3));
                    const blue = Math.round(255 * (1 - factor * 0.3));
                    return `rgb(${red},${green},${blue})`;
                } else {
                    // 薄いピンク → 濃い赤
                    const factor = (intensity - 0.5) * 2;
                    const red = 255;
                    const green = Math.round(180 * (1 - factor));
                    const blue = Math.round(180 * (1 - factor));
                    return `rgb(${red},${green},${blue})`;
                }
            } else if (value < 0 && negativeMin < 0) {
                // マイナス側：白→青系のグラデーション
                const intensity = Math.min(Math.abs(value / negativeMin), 1.0);
                
                if (intensity <= 0.5) {
                    // 白 → 薄い水色
                    const factor = intensity * 2;
                    const red = Math.round(255 * (1 - factor * 0.3));
                    const green = Math.round(255 * (1 - factor * 0.1));
                    const blue = 255;
                    return `rgb(${red},${green},${blue})`;
                } else {
                    // 薄い水色 → 濃い青
                    const factor = (intensity - 0.5) * 2;
                    const red = Math.round(180 * (1 - factor));
                    const green = Math.round(230 * (1 - factor));
                    const blue = 255;
                    return `rgb(${red},${green},${blue})`;
                }
            } else {
                // フォールバック
                return 'rgb(255,255,255)'; // 白
            }
        }
        
        // ヒートマップ色取得関数
        function getHeatmapColor(ratio) {
            // 0%〜2%の範囲を青色で表示
            if (ratio >= 0 && ratio <= 0.02) {
                return 'rgb(0,0,255)'; // 青
            }
            
            // 98%〜100%の範囲を赤色で表示
            if (ratio >= 0.98 && ratio <= 1.0) {
                return 'rgb(255,0,0)'; // 赤
            }
            
            // 48%〜52%の範囲を白色で表示し、メリハリを強調
            if (ratio >= 0.48 && ratio <= 0.52) {
                return 'rgb(255,255,255)'; // 白
            }
            
            // 青→緑めの青→白→黄色が混じるオレンジ→赤のグラデーション
            const colors = [
                [0, 0, 255],     // 青 (0-2%)
                [0, 255, 216],   // 緑めの青 (25%)
                [255, 255, 255], // 白 (48-52%)
                [255, 217, 0],   // 黄色が混じるオレンジ (75%)
                [255, 0, 0]      // 赤 (98-100%)
            ];
            
            // 比率を調整（固定色範囲を除く）
            let adjustedRatio;
            if (ratio > 0.02 && ratio < 0.48) {
                // 2%〜48%の範囲を0〜0.5にマッピング
                adjustedRatio = ((ratio - 0.02) / 0.46) * 0.5;
            } else if (ratio > 0.52 && ratio < 0.98) {
                // 52%〜98%の範囲を0.5〜1にマッピング
                adjustedRatio = 0.5 + ((ratio - 0.52) / 0.46) * 0.5;
            } else {
                // フォールバック（通常は上の条件で処理される）
                adjustedRatio = ratio;
            }
            
            const scaledRatio = adjustedRatio * (colors.length - 1);
            const index = Math.floor(scaledRatio);
            const fraction = scaledRatio - index;
            
            if (index >= colors.length - 1) {
                return `rgb(${colors[colors.length - 1].join(',')})`;
            }
            
            const color1 = colors[index];
            const color2 = colors[index + 1];
            
            const r = Math.round(color1[0] + (color2[0] - color1[0]) * fraction);
            const g = Math.round(color1[1] + (color2[1] - color1[1]) * fraction);
            const b = Math.round(color1[2] + (color2[2] - color1[2]) * fraction);
            
            return `rgb(${r},${g},${b})`;
        }
        
        // 色分け凡例更新関数
        function updateColorLegend() {
            if (!fieldStats.isNumeric) return;
            
            legendContent.innerHTML = '';
            
            // 数値以外のデータがある場合は説明を追加
            if (fieldStats.values.length > fieldStats.numericValues.length) {
                const nonNumericItem = document.createElement('div');
                nonNumericItem.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = '#cccccc';
                
                const label = document.createElement('span');
                label.textContent = '非数値データ';
                
                nonNumericItem.appendChild(colorBox);
                nonNumericItem.appendChild(label);
                legendContent.appendChild(nonNumericItem);
            }
            
            // データ範囲に0が含まれるかチェック
            const includesZero = fieldStats.min <= 0 && fieldStats.max >= 0;
            
            if (includesZero) {
                // 0基準の凡例（シンプルに5段階で表示）
                
                // プラス側最大値
                if (fieldStats.max > 0) {
                    const legendItem1 = document.createElement('div');
                    legendItem1.className = 'legend-item';
                    
                    const colorBox1 = document.createElement('div');
                    colorBox1.className = 'legend-color';
                    colorBox1.style.backgroundColor = 'rgb(255,0,0)';
                    
                    const label1 = document.createElement('span');
                    label1.textContent = fieldStats.isInteger ? fieldStats.max.toString() : fieldStats.max.toFixed(2);
                    
                    legendItem1.appendChild(colorBox1);
                    legendItem1.appendChild(label1);
                    legendContent.appendChild(legendItem1);
                    
                    // プラス側中間値
                    const legendItem2 = document.createElement('div');
                    legendItem2.className = 'legend-item';
                    
                    const colorBox2 = document.createElement('div');
                    colorBox2.className = 'legend-color';
                    colorBox2.style.backgroundColor = 'rgb(255,128,128)';
                    
                    const label2 = document.createElement('span');
                    const midPositive = fieldStats.max * 0.5;
                    label2.textContent = fieldStats.isInteger ? Math.round(midPositive).toString() : midPositive.toFixed(2);
                    
                    legendItem2.appendChild(colorBox2);
                    legendItem2.appendChild(label2);
                    legendContent.appendChild(legendItem2);
                }
                
                // ゼロ値
                const zeroItem = document.createElement('div');
                zeroItem.className = 'legend-item';
                
                const zeroColorBox = document.createElement('div');
                zeroColorBox.className = 'legend-color';
                zeroColorBox.style.backgroundColor = 'rgb(255,255,255)';
                zeroColorBox.style.border = '1px solid #999';
                
                const zeroLabel = document.createElement('span');
                zeroLabel.textContent = '0';
                
                zeroItem.appendChild(zeroColorBox);
                zeroItem.appendChild(zeroLabel);
                legendContent.appendChild(zeroItem);
                
                // マイナス側
                if (fieldStats.min < 0) {
                    // マイナス側中間値
                    const legendItem3 = document.createElement('div');
                    legendItem3.className = 'legend-item';
                    
                    const colorBox3 = document.createElement('div');
                    colorBox3.className = 'legend-color';
                    colorBox3.style.backgroundColor = 'rgb(128,128,255)';
                    
                    const label3 = document.createElement('span');
                    const midNegative = fieldStats.min * 0.5;
                    label3.textContent = fieldStats.isInteger ? Math.round(midNegative).toString() : midNegative.toFixed(2);
                    
                    legendItem3.appendChild(colorBox3);
                    legendItem3.appendChild(label3);
                    legendContent.appendChild(legendItem3);
                    
                    // マイナス側最小値
                    const legendItem4 = document.createElement('div');
                    legendItem4.className = 'legend-item';
                    
                    const colorBox4 = document.createElement('div');
                    colorBox4.className = 'legend-color';
                    colorBox4.style.backgroundColor = 'rgb(0,0,255)';
                    
                    const label4 = document.createElement('span');
                    label4.textContent = fieldStats.isInteger ? fieldStats.min.toString() : fieldStats.min.toFixed(2);
                    
                    legendItem4.appendChild(colorBox4);
                    legendItem4.appendChild(label4);
                    legendContent.appendChild(legendItem4);
                }
                
            } else {
                // 0を含まない場合：従来の最大最小基準凡例
                const steps = 5;
                // 最高値から最小値の順で表示（逆順）
                for (let i = steps; i >= 0; i--) {
                    const ratio = i / steps;
                    const value = fieldStats.min + (fieldStats.max - fieldStats.min) * ratio;
                    const color = getHeatmapColor(ratio);
                    
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = color;
                    
                    const label = document.createElement('span');
                    // 整数の場合は小数点なし、小数の場合は2桁まで表示
                    label.textContent = fieldStats.isInteger ? Math.round(value).toString() : value.toFixed(2);
                    
                    legendItem.appendChild(colorBox);
                    legendItem.appendChild(label);
                    legendContent.appendChild(legendItem);
                }
            }
        }
        
        // ラベル更新関数
        function updateLabels() {
            // 既存のラベルレイヤーを削除
            if (map.getLayer('geojson-labels')) {
                map.removeLayer('geojson-labels');
            }
            
            if (!currentField || !currentGeoJSON) return;
            
            // ジオメトリタイプを判定
            const geometryTypes = new Set();
            if (currentGeoJSON.features) {
                currentGeoJSON.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.type) {
                        geometryTypes.add(feature.geometry.type);
                    }
                });
            }
            
            // ポイントデータが含まれているかチェック
            const hasPoints = geometryTypes.has('Point') || geometryTypes.has('MultiPoint');
            const hasNonPoints = geometryTypes.has('Polygon') || geometryTypes.has('MultiPolygon') || 
                               geometryTypes.has('LineString') || geometryTypes.has('MultiLineString');
            
            // ポイントデータのみの場合、ラベルを上にシフト
            let textAnchor = 'center';
            let textOffset = [0, 0];
            
            if (hasPoints && !hasNonPoints) {
                // ポイントデータのみの場合：ラベルを点の上に表示
                textAnchor = 'bottom';
                textOffset = [0, -1.5];  // 上方向にシフト
            } else if (hasPoints && hasNonPoints) {
                // 混合データの場合：ポイントには条件付きでオフセットを適用
                textAnchor = 'center';
                textOffset = [
                    'case',
                    ['in', ['geometry-type'], ['literal', ['Point', 'MultiPoint']]],
                    ['literal', [0, -1.5]],  // ポイントの場合は上にシフト
                    ['literal', [0, 0]]      // その他は中央
                ];
            }
            
            // ラベル表示用のレイヤーを追加
            const labelLayer = {
                'id': 'geojson-labels',
                'type': 'symbol',
                'source': 'geojson',
                'layout': {
                    'text-field': ['get', currentField],
                    'text-font': ['Open Sans Regular'],
                    'text-size': 12,
                    'text-anchor': textAnchor,
                    'text-offset': textOffset,
                    'text-allow-overlap': true,
                    'text-ignore-placement': false,
                    'visibility': 'visible'
                },
                'paint': {
                    'text-color': '#000',
                    'text-halo-color': '#fff',
                    'text-halo-width': 2,
                    'text-opacity': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        19, 0,      // ズームレベル19で完全非表示
                        20, 1       // ズームレベル20で完全表示
                    ]
                }
            };
            
            // 混合データの場合、text-anchorも条件付きで設定
            if (hasPoints && hasNonPoints) {
                labelLayer.layout['text-anchor'] = [
                    'case',
                    ['in', ['geometry-type'], ['literal', ['Point', 'MultiPoint']]],
                    'bottom',    // ポイントの場合は下寄せ（ラベルが上に表示される）
                    'center'     // その他は中央
                ];
            }
            
            map.addLayer(labelLayer);
            
            // ポリゴンの色はヒートマップモードでない場合のみリセット
            if (!isHeatmapMode && map.getLayer('geojson-fill')) {
                map.setPaintProperty('geojson-fill', 'fill-color', '#088');
            }
        }
        
        // マップをGeoJSONの範囲に合わせる関数
        function fitMapToGeoJSON(geoJSON) {
            if (!geoJSON.features || geoJSON.features.length === 0) return;
            
            const bounds = new maplibregl.LngLatBounds();
            
            geoJSON.features.forEach(feature => {
                if (!feature.geometry) return;
                
                switch (feature.geometry.type) {
                    case 'Point':
                        bounds.extend(feature.geometry.coordinates);
                        break;
                        
                    case 'MultiPoint':
                        feature.geometry.coordinates.forEach(coord => {
                            bounds.extend(coord);
                        });
                        break;
                        
                    case 'LineString':
                        feature.geometry.coordinates.forEach(coord => {
                            bounds.extend(coord);
                        });
                        break;
                        
                    case 'MultiLineString':
                        feature.geometry.coordinates.forEach(line => {
                            line.forEach(coord => {
                                bounds.extend(coord);
                            });
                        });
                        break;
                        
                    case 'Polygon':
                        feature.geometry.coordinates[0].forEach(coord => {
                            bounds.extend(coord);
                        });
                        break;
                        
                    case 'MultiPolygon':
                        feature.geometry.coordinates.forEach(polygon => {
                            polygon[0].forEach(coord => {
                                bounds.extend(coord);
                            });
                        });
                        break;
                        
                    case 'GeometryCollection':
                        // GeometryCollectionの場合は再帰的に処理
                        feature.geometry.geometries.forEach(geometry => {
                            const tempFeature = { geometry: geometry };
                            fitMapToGeoJSON({ features: [tempFeature] });
                        });
                        break;
                        
                    default:
                        console.warn('未対応のジオメトリタイプ:', feature.geometry.type);
                }
            });
            
            // boundsが有効な場合のみ移動
            if (!bounds.isEmpty()) {
                map.fitBounds(bounds, { padding: 50 });
            } else {
                console.warn('有効な座標が見つかりませんでした');
            }
        }
        
        // マップをGeoTIFFの範囲に合わせる関数
        function fitMapToGeoTIFF(bbox) {
            if (!bbox || bbox.length !== 4) {
                console.warn('GeoTIFFのbbox情報が無効です:', bbox);
                return;
            }
            
            // bbox: [minX, minY, maxX, maxY] 形式
            const [minX, minY, maxX, maxY] = bbox;
            
            // MapLibre GLのLngLatBounds形式に変換
            const bounds = new maplibregl.LngLatBounds([minX, minY], [maxX, maxY]);
            
            // マップを範囲に合わせる
            map.fitBounds(bounds, { 
                padding: 50,
                duration: 1000  // アニメーション時間を指定
            });
            
            console.log('GeoTIFFの範囲に移動:', { minX, minY, maxX, maxY });
        }
        
        // ステータス表示関数
        function showStatus(message, type) {
            status.textContent = message;
            status.className = `status ${type}`;
            
            if (type === 'success') {
                setTimeout(() => {
                    status.textContent = '';
                    status.className = 'status';
                }, 3000);
            }
        }
        
        // マップクリックイベント（フィーチャ情報表示）- すべてのレイヤータイプに対応
        function addMapClickEvents() {
            const layers = ['geojson-fill', 'geojson-line', 'geojson-point'];
            
            layers.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.on('click', layerId, (e) => {
                        const properties = e.features[0].properties;
                        let popupContent = '<h4>フィーチャ情報</h4>';
                        
                        Object.keys(properties).forEach(key => {
                            popupContent += `<p><strong>${key}:</strong> ${properties[key]}</p>`;
                        });
                        
                        new maplibregl.Popup()
                            .setLngLat(e.lngLat)
                            .setHTML(popupContent)
                            .addTo(map);
                    });
                    
                    // マウスカーソル変更
                    map.on('mouseenter', layerId, () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    
                    map.on('mouseleave', layerId, () => {
                        map.getCanvas().style.cursor = '';
                    });
                }
            });
        }
        
        // レイヤー追加後にイベントを設定するためのヘルパー関数
        function setupLayerEvents() {
            // 既存のイベントをクリア（重複防止）
            map.off('click');
            map.off('mouseenter');
            map.off('mouseleave');
            
            // 新しいイベントを追加
            addMapClickEvents();
        }
        
        // パネル位置調整関数
        function adjustPanelPositions() {
            let currentTop = 10;
            
            // GeoJSON選択パネル
            if (!fileInputContainer.classList.contains('minimized')) {
                fileInputContainer.style.top = currentTop + 'px';
                currentTop += fileInputContainer.offsetHeight + 10;
            } else {
                fileInputContainer.style.top = currentTop + 'px';
                currentTop += 60; // 最小化時の高さ + マージン
            }
            
            // 表示設定パネル
            if (controls.style.display !== 'none') {
                if (!controls.classList.contains('minimized')) {
                    controls.style.top = currentTop + 'px';
                    currentTop += controls.offsetHeight + 10;
                } else {
                    controls.style.top = currentTop + 'px';
                    currentTop += 60; // 最小化時の高さ + マージン
                }
            }
            
            // GeoTIFFパネル
            if (!geotiffControls.classList.contains('minimized')) {
                geotiffControls.style.top = currentTop + 'px';
                currentTop += geotiffControls.offsetHeight + 10;
            } else {
                geotiffControls.style.top = currentTop + 'px';
                currentTop += 60; // 最小化時の高さ + マージン
            }
            
            // 計測パネル
            if (!measureControls.classList.contains('minimized')) {
                measureControls.style.top = currentTop + 'px';
                currentTop += measureControls.offsetHeight + 10;
            } else {
                measureControls.style.top = currentTop + 'px';
                currentTop += 60; // 最小化時の高さ + マージン
            }
            
            // ベースマップパネル
            basemapControls.style.bottom = '10px';
            basemapControls.style.top = 'auto';
            basemapControls.style.left = '10px';
        }
        
        // 計測開始関数
        function startMeasure(mode) {
            // 既存の計測をクリア
            clearMeasurements();
            
            measureMode = mode;
            measurePoints = [];
            
            // ボタンの状態を更新
            measureDistance.classList.remove('active');
            measureArea.classList.remove('active');
            
            if (mode === 'distance') {
                measureDistance.classList.add('active');
                measureResult.textContent = '地図上をクリックして距離を計測してください';
                map.getCanvas().style.cursor = 'crosshair';
            } else if (mode === 'area') {
                measureArea.classList.add('active');
                measureResult.textContent = '地図上をクリックして面積を計測してください（3点以上）';
                map.getCanvas().style.cursor = 'crosshair';
            }
            
            // マップクリックイベントを追加
            map.on('click', handleMeasureClick);
        }
        
        // 計測クリックハンドラ
        function handleMeasureClick(e) {
            if (!measureMode) return;
            
            const point = [e.lngLat.lng, e.lngLat.lat];
            measurePoints.push(point);
            
            // 小さな丸のマーカーを追加
            const markerElement = document.createElement('div');
            markerElement.style.width = '8px';
            markerElement.style.height = '8px';
            markerElement.style.backgroundColor = '#ff6b35';
            markerElement.style.borderRadius = '50%';
            markerElement.style.border = '2px solid white';
            markerElement.style.boxShadow = '0 0 4px rgba(0,0,0,0.3)';
            
            const marker = new maplibregl.Marker({ element: markerElement })
                .setLngLat(point)
                .addTo(map);
            measureMarkers.push(marker);
            
            if (measureMode === 'distance') {
                handleDistanceMeasure();
            } else if (measureMode === 'area') {
                handleAreaMeasure();
            }
        }
        
        // 距離計測処理
        function handleDistanceMeasure() {
            if (measurePoints.length === 1) {
                measureResult.textContent = '次の点をクリックしてください';
                return;
            }
            
            // 線を描画
            if (measurePoints.length >= 2) {
                const lastTwoPoints = measurePoints.slice(-2);
                
                // 既存のソースとレイヤーがあるかチェック
                if (!map.getSource('measure-line')) {
                    map.addSource('measure-line', {
                        type: 'geojson',
                        data: {
                            type: 'Feature',
                            geometry: {
                                type: 'LineString',
                                coordinates: measurePoints
                            }
                        }
                    });
                    
                    map.addLayer({
                        id: 'measure-line',
                        type: 'line',
                        source: 'measure-line',
                        paint: {
                            'line-color': '#ff6b35',
                            'line-width': 3
                        }
                    });
                } else {
                    // 既存のソースを更新
                    map.getSource('measure-line').setData({
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: measurePoints
                        }
                    });
                }
            }
            
            // 総距離を計算
            let totalDistance = 0;
            for (let i = 1; i < measurePoints.length; i++) {
                totalDistance += calculateDistance(measurePoints[i-1], measurePoints[i]);
            }
            
            measureResult.textContent = `距離: ${formatDistance(totalDistance)} (クリックで続行、Escで終了)`;
        }
        
        // 面積計測処理
        function handleAreaMeasure() {
            if (measurePoints.length < 3) {
                measureResult.textContent = `${3 - measurePoints.length}点以上必要です`;
                return;
            }
            
            // ポリゴンを描画
            const polygonCoords = [...measurePoints, measurePoints[0]]; // 閉じたポリゴン
            
            if (!map.getSource('measure-polygon')) {
                map.addSource('measure-polygon', {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Polygon',
                            coordinates: [polygonCoords]
                        }
                    }
                });
                
                map.addLayer({
                    id: 'measure-polygon-fill',
                    type: 'fill',
                    source: 'measure-polygon',
                    paint: {
                        'fill-color': '#ff6b35',
                        'fill-opacity': 0.3
                    }
                });
                
                map.addLayer({
                    id: 'measure-polygon-line',
                    type: 'line',
                    source: 'measure-polygon',
                    paint: {
                        'line-color': '#ff6b35',
                        'line-width': 3
                    }
                });
            } else {
                // 既存のソースを更新
                map.getSource('measure-polygon').setData({
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [polygonCoords]
                    }
                });
            }
            
            // 面積を計算
            const area = calculatePolygonArea(measurePoints);
            measureResult.textContent = `面積: ${formatArea(area)} (クリックで続行、Escで終了)`;
        }
        
        // 計測をクリア
        function clearMeasurements() {
            measureMode = null;
            measurePoints = [];
            
            // マーカーを削除
            measureMarkers.forEach(marker => marker.remove());
            measureMarkers = [];
            
            // レイヤーとソースを削除
            if (map.getLayer('measure-line')) {
                map.removeLayer('measure-line');
                map.removeSource('measure-line');
            }
            if (map.getLayer('measure-polygon-fill')) {
                map.removeLayer('measure-polygon-fill');
            }
            if (map.getLayer('measure-polygon-line')) {
                map.removeLayer('measure-polygon-line');
            }
            if (map.getSource('measure-polygon')) {
                map.removeSource('measure-polygon');
            }
            
            // ボタンの状態をリセット
            measureDistance.classList.remove('active');
            measureArea.classList.remove('active');
            
            // カーソルをリセット
            map.getCanvas().style.cursor = '';
            
            // イベントリスナーを削除
            map.off('click', handleMeasureClick);
            
            measureResult.textContent = '';
        }
        
        // 2点間の距離を計算（メートル単位）
        function calculateDistance([lng1, lat1], [lng2, lat2]) {
            const R = 6371000; // 地球の半径（メートル）
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lng2 - lng1) * Math.PI / 180;
            
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }
        
        // ポリゴンの面積を計算（平方メートル単位）
        function calculatePolygonArea(coordinates) {
            if (coordinates.length < 3) return 0;
            
            let area = 0;
            const n = coordinates.length;
            
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                const [lng1, lat1] = coordinates[i];
                const [lng2, lat2] = coordinates[j];
                
                area += (lng2 - lng1) * (lat2 + lat1);
            }
            
            area = Math.abs(area) / 2;
            
            // 度からメートルへの概算変換（緯度による補正）
            const avgLat = coordinates.reduce((sum, coord) => sum + coord[1], 0) / coordinates.length;
            const latFactor = Math.cos(avgLat * Math.PI / 180);
            const meterPerDegree = 111320; // 1度あたりのメートル数（概算）
            
            return area * meterPerDegree * meterPerDegree * latFactor;
        }
        
        // 距離をフォーマット
        function formatDistance(meters) {
            if (meters < 1000) {
                return `${meters.toFixed(1)} m`;
            } else {
                return `${(meters / 1000).toFixed(2)} km`;
            }
        }
        
        // 面積をフォーマット
        function formatArea(squareMeters) {
            if (squareMeters < 10000) {
                return `${squareMeters.toFixed(1)} m²`;
            } else {
                return `${(squareMeters / 10000).toFixed(2)} ha`;
            }
        }
        
        
        // 初期パネル位置を調整
        setTimeout(adjustPanelPositions, 100);
        
        // Proj4js初期化
        initializeProjections();
    </script>
</body>
</html>