<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON - Heatmap</title>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <!-- GeoTIFF解析用ライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.1.1/dist-browser/geotiff.js"></script>
    <!-- カスタムスタイルシート -->
    <link href="styles.css" rel="stylesheet" />
</head>
<body>
    <div id="map"></div>
    
    <!-- ドラッグ&ドロップ用のオーバーレイ -->
    <div class="drop-overlay" id="dropOverlay">
        <div class="drop-message">
            <div>ファイルをここにドロップ</div>
            <div style="font-size: 14px; margin-top: 10px; font-weight: normal;">
                GeoJSON: .geojson, .json<br>
                GeoTIFF: .tif, .tiff
            </div>
        </div>
    </div>
    
    <!-- ファイル選択ボタン -->
    <div class="file-input-container minimized" id="fileInputContainer">
        <div class="panel-header">
            <h4>GeoJson選択・画面上にドロップ</h4>
            <button class="close-button" id="fileInputClose" title="最小化">×</button>
        </div>
        <div class="file-input-content">
            <input type="file" id="fileInput" accept=".geojson,.json">
        </div>
        <div class="minimized-text">選択</div>
    </div>
    
    <!-- 表示設定パネル（GeoJSON読み込み後に表示） -->
    <div class="controls" id="controls" style="display: none;">
        <div class="panel-header">
            <h4>表示設定</h4>
            <button class="close-button" id="controlsClose" title="最小化">×</button>
        </div>
        <div class="controls-content">
            <div class="field-selector">
                <label for="fieldSelect">表示フィールド:</label>
                <select id="fieldSelect">
                    <option value="">選択してください</option>
                </select>
            </div>
            <div class="label-mode">
                <label>
                    <input type="checkbox" id="labelMode" checked> 文字ラベル表示
                </label>
            </div>
            <div class="color-mode">
                <label>
                    <input type="checkbox" id="heatmapMode"> ヒートマップ表示
                </label>
            </div>
            <div class="line-width-control">
                <label for="lineWidth">ライン幅:</label>
                <div class="line-width-controls">
                    <input type="range" id="lineWidth" min="0" max="3" value="2" step="0.1">
                    <div class="line-width-value" id="lineWidthValue">2.0</div>
                </div>
            </div>
            <div class="color-legend" id="colorLegend" style="display: none;">
                <h5>色分け凡例</h5>
                <div id="legendContent"></div>
            </div>
            <div class="info">
                <div>フィーチャ数: <span id="featureCount">0</span></div>
                <div id="fieldInfo" style="margin-top: 5px;"></div>
            </div>
            <div id="status"></div>
        </div>
        <div class="minimized-text">表示</div>
    </div>

    <!-- 背景地図コントロール -->
    <div class="basemap-controls minimized" id="basemapControls">
        <div class="panel-header">
            <h4>背景地図</h4>
            <button class="close-button" id="basemapClose" title="最小化">×</button>
        </div>
        <div class="basemap-content">
            <div class="basemap-selector">
                <label for="basemapSelect">地図種別:</label>
                <select id="basemapSelect">
                    <option value="osm">OpenStreetMap</option>
                    <option value="gsi-pale">地理院地図（淡色）</option>
                    <option value="gsi-photo">地理院地図（写真）</option>
                </select>
            </div>
            <div class="basemap-opacity">
                <label for="basemapOpacity">透明度:</label>
                <div class="opacity-controls">
                    <input type="range" id="basemapOpacity" min="0" max="100" value="100" step="1">
                    <div class="opacity-value" id="opacityValue">100%</div>
                </div>
            </div>
        </div>
        <div class="minimized-text">背景</div>
    </div>

    <!-- GeoTIFFコントロール -->
    <div class="geotiff-controls minimized" id="geotiffControls">
        <div class="panel-header">
            <h4>GeoTIFF</h4>
            <button class="close-button" id="geotiffClose" title="最小化">×</button>
        </div>
        <div class="geotiff-content">
            <div class="geotiff-file-input">
                <input type="file" id="geotiffInput" accept=".tif,.tiff" title="GeoTIFFファイルを選択">
            </div>
            <div class="geotiff-opacity">
                <label for="geotiffOpacity">透明度:</label>
                <div class="geotiff-opacity-controls">
                    <input type="range" id="geotiffOpacity" min="0" max="100" value="70" step="1">
                    <div class="geotiff-opacity-value" id="geotiffOpacityValue">70%</div>
                </div>
            </div>
            <div id="geotiffStatus" class="geotiff-status" style="display: none;"></div>
            <button id="geotiffRemove" class="geotiff-remove-btn" style="display: none;">GeoTIFF削除</button>
        </div>
        <div class="minimized-text">TIFF</div>
    </div>

    <!-- 計測コントロール -->
    <div class="measure-controls minimized" id="measureControls">
        <div class="panel-header">
            <h4>計測ツール</h4>
            <button class="close-button" id="measureClose" title="最小化">×</button>
        </div>
        <div class="measure-content">
            <div class="measure-buttons">
                <button class="measure-btn" id="measureDistance">距離計測</button>
                <button class="measure-btn" id="measureArea">面積計測</button>
            </div>
            <div id="measureResult" class="measure-result"></div>
            <button id="measureClear" class="measure-clear">計測をクリア</button>
        </div>
        <div class="minimized-text">計測</div>
    </div>

    <script>
        // 前橋市役所の座標 (緯度: 36.389494, 経度: 139.063437)
        const MAEBASHI_CITY_HALL = [139.063437, 36.389494];
        
        // 背景地図の定義
        const basemapStyles = {
            osm: {
                'version': 8,
                'glyphs': 'https://fonts.openmaptiles.org/{fontstack}/{range}.pbf',
                'sources': {
                    'osm': {
                        'type': 'raster',
                        'tiles': [
                            'https://tile.openstreetmap.org/{z}/{x}/{y}.png'
                        ],
                        'tileSize': 256,
                        'attribution': '© OpenStreetMap contributors'
                    }
                },
                'layers': [{
                    'id': 'basemap',
                    'type': 'raster',
                    'source': 'osm'
                }]
            },
            'gsi-pale': {
                'version': 8,
                'glyphs': 'https://fonts.openmaptiles.org/{fontstack}/{range}.pbf',
                'sources': {
                    'gsi-pale': {
                        'type': 'raster',
                        'tiles': [
                            'https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png'
                        ],
                        'tileSize': 256,
                        'attribution': '© 国土地理院'
                    }
                },
                'layers': [{
                    'id': 'basemap',
                    'type': 'raster',
                    'source': 'gsi-pale'
                }]
            },
            'gsi-photo': {
                'version': 8,
                'glyphs': 'https://fonts.openmaptiles.org/{fontstack}/{range}.pbf',
                'sources': {
                    'gsi-photo': {
                        'type': 'raster',
                        'tiles': [
                            'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg'
                        ],
                        'tileSize': 256,
                        'attribution': '© 国土地理院'
                    }
                },
                'layers': [{
                    'id': 'basemap',
                    'type': 'raster',
                    'source': 'gsi-photo'
                }]
            }
        };
        
        // マップの初期化
        const map = new maplibregl.Map({
            container: 'map',
            style: basemapStyles.osm,
            center: MAEBASHI_CITY_HALL,
            zoom: 15,
            maxZoom: 22
        });
        
        // 標準コントロールを追加
        map.addControl(new maplibregl.NavigationControl(), 'top-right');
        
        // 現在位置取得コントロールを追加
        map.addControl(new maplibregl.GeolocateControl({
            positionOptions: {
                enableHighAccuracy: true  // 高精度位置情報を使用
            },
            trackUserLocation: true,      // ユーザーの位置を追跡
            showUserHeading: true,        // ユーザーの向きを表示
            showAccuracyCircle: true      // 精度円を表示
        }), 'top-right');
        
        // 前橋市役所にマーカーを追加
        new maplibregl.Marker({ color: '#ff0000' })
            .setLngLat(MAEBASHI_CITY_HALL)
            .setPopup(new maplibregl.Popup().setHTML('<h4>前橋市役所</h4>'))
            .addTo(map);
        
        let currentGeoJSON = null;
        let currentField = null;
        let isHeatmapMode = false;
        
        // 複数GeoJSON管理用の変数
        let geoJSONLayerCounter = 0;
        let isFirstGeoJSON = true;
        let isLabelMode = true;
        let fieldStats = null;
        let currentBasemap = 'osm';
        let currentGeoTIFF = null;
        let geotiffCanvas = null;
        
        // 計測関連変数
        let measureMode = null; // 'distance', 'area', null
        let measurePoints = [];
        let measureMarkers = [];
        let measureLines = [];
        let measurePolygons = [];
        
        // DOM要素の取得
        const dropOverlay = document.getElementById('dropOverlay');
        const fileInput = document.getElementById('fileInput');
        const fileInputContainer = document.getElementById('fileInputContainer');
        const fileInputClose = document.getElementById('fileInputClose');
        const controls = document.getElementById('controls');
        const controlsClose = document.getElementById('controlsClose');
        const basemapControls = document.getElementById('basemapControls');
        const basemapClose = document.getElementById('basemapClose');
        const basemapSelect = document.getElementById('basemapSelect');
        const basemapOpacity = document.getElementById('basemapOpacity');
        const opacityValue = document.getElementById('opacityValue');
        const fieldSelect = document.getElementById('fieldSelect');
        const featureCount = document.getElementById('featureCount');
        const status = document.getElementById('status');
        const heatmapMode = document.getElementById('heatmapMode');
        const labelMode = document.getElementById('labelMode');
        const colorLegend = document.getElementById('colorLegend');
        const legendContent = document.getElementById('legendContent');
        const fieldInfo = document.getElementById('fieldInfo');
        const lineWidth = document.getElementById('lineWidth');
        const lineWidthValue = document.getElementById('lineWidthValue');
        
        // GeoTIFF関連のDOM要素
        const geotiffControls = document.getElementById('geotiffControls');
        const geotiffClose = document.getElementById('geotiffClose');
        const geotiffInput = document.getElementById('geotiffInput');
        const geotiffOpacity = document.getElementById('geotiffOpacity');
        const geotiffOpacityValue = document.getElementById('geotiffOpacityValue');
        const geotiffStatus = document.getElementById('geotiffStatus');
        const geotiffRemove = document.getElementById('geotiffRemove');
        
        // 計測関連のDOM要素
        const measureControls = document.getElementById('measureControls');
        const measureClose = document.getElementById('measureClose');
        const measureDistance = document.getElementById('measureDistance');
        const measureArea = document.getElementById('measureArea');
        const measureResult = document.getElementById('measureResult');
        const measureClear = document.getElementById('measureClear');
        
        // パネルの最小化/復元機能
        fileInputClose.addEventListener('click', (e) => {
            e.stopPropagation();
            fileInputContainer.classList.add('minimized');
            setTimeout(adjustPanelPositions, 100);
        });
        
        fileInputContainer.addEventListener('click', (e) => {
            if (fileInputContainer.classList.contains('minimized')) {
                e.stopPropagation();
                fileInputContainer.classList.remove('minimized');
                setTimeout(adjustPanelPositions, 100);
            }
        });
        
        controlsClose.addEventListener('click', (e) => {
            e.stopPropagation();
            controls.classList.add('minimized');
            setTimeout(adjustPanelPositions, 100);
        });
        
        controls.addEventListener('click', (e) => {
            if (controls.classList.contains('minimized')) {
                e.stopPropagation();
                controls.classList.remove('minimized');
                setTimeout(adjustPanelPositions, 100);
            }
        });
        
        // 背景地図パネルの最小化/復元機能
        basemapClose.addEventListener('click', (e) => {
            e.stopPropagation();
            basemapControls.classList.add('minimized');
        });
        
        basemapControls.addEventListener('click', (e) => {
            if (basemapControls.classList.contains('minimized')) {
                e.stopPropagation();
                basemapControls.classList.remove('minimized');
            }
        });
        
        // GeoTIFFパネルの最小化/復元機能
        geotiffClose.addEventListener('click', (e) => {
            e.stopPropagation();
            geotiffControls.classList.add('minimized');
            setTimeout(adjustPanelPositions, 100);
        });
        
        geotiffControls.addEventListener('click', (e) => {
            if (geotiffControls.classList.contains('minimized')) {
                e.stopPropagation();
                geotiffControls.classList.remove('minimized');
                setTimeout(adjustPanelPositions, 100);
            }
        });
        
        // 計測パネルの最小化/復元機能
        measureClose.addEventListener('click', (e) => {
            e.stopPropagation();
            measureControls.classList.add('minimized');
            setTimeout(adjustPanelPositions, 100);
        });
        
        measureControls.addEventListener('click', (e) => {
            if (measureControls.classList.contains('minimized')) {
                e.stopPropagation();
                measureControls.classList.remove('minimized');
                setTimeout(adjustPanelPositions, 100);
            }
        });
        
        // ウィンドウ全体でのドラッグ&ドロップイベント
        let dragCounter = 0;
        
        window.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            if (dragCounter === 1) {
                dropOverlay.classList.add('active');
            }
        });
        
        window.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dropOverlay.classList.remove('active');
            }
        });
        
        window.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        
        window.addEventListener('drop', (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropOverlay.classList.remove('active');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff')) {
                    handleGeoTIFFFile(file);
                } else {
                    handleFile(file);
                }
            }
        });
        
        // ファイル選択イベント
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        // フィールド選択イベント
        fieldSelect.addEventListener('change', (e) => {
            currentField = e.target.value;
            if (currentField && currentGeoJSON) {
                analyzeField();
                updateVisualization();
            } else {
                clearVisualization();
            }
        });
        
        // ヒートマップモード切り替えイベント
        heatmapMode.addEventListener('change', (e) => {
            isHeatmapMode = e.target.checked;
            if (currentField && currentGeoJSON) {
                updateVisualization();
            }
        });
        
        // ラベルモード切り替えイベント
        labelMode.addEventListener('change', (e) => {
            isLabelMode = e.target.checked;
            if (currentField && currentGeoJSON) {
                updateVisualization();
            }
        });
        
        // 背景地図切り替えイベント
        basemapSelect.addEventListener('change', (e) => {
            currentBasemap = e.target.value;
            changeBasemap(currentBasemap);
        });
        
        // 背景地図透明度切り替えイベント
        basemapOpacity.addEventListener('input', (e) => {
            const opacity = parseInt(e.target.value) / 100;
            opacityValue.textContent = e.target.value + '%';
            
            if (map.getLayer('basemap')) {
                map.setPaintProperty('basemap', 'raster-opacity', opacity);
            }
        });
        
        // ライン幅調整イベント
        lineWidth.addEventListener('input', (e) => {
            const width = parseFloat(e.target.value);
            lineWidthValue.textContent = width.toFixed(1);
            
            if (map.getLayer('geojson-line')) {
                map.setPaintProperty('geojson-line', 'line-width', width);
            }
        });
        
        // GeoTIFFファイル選択イベント
        geotiffInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleGeoTIFFFile(e.target.files[0]);
            }
        });
        
        // GeoTIFF透明度調整イベント
        geotiffOpacity.addEventListener('input', (e) => {
            const opacity = parseInt(e.target.value) / 100;
            geotiffOpacityValue.textContent = e.target.value + '%';
            
            if (map.getSource('geotiff')) {
                map.setPaintProperty('geotiff-layer', 'raster-opacity', opacity);
            }
        });
        
        // GeoTIFF削除イベント
        geotiffRemove.addEventListener('click', () => {
            removeGeoTIFF();
        });
        
        // 計測機能イベント
        measureDistance.addEventListener('click', () => {
            startMeasure('distance');
        });
        
        measureArea.addEventListener('click', () => {
            startMeasure('area');
        });
        
        measureClear.addEventListener('click', () => {
            clearMeasurements();
        });
        
        // ESCキーで計測終了
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && measureMode) {
                clearMeasurements();
            }
        });
        
        // ファイル処理関数
        function handleFile(file) {
            if (!file.name.toLowerCase().endsWith('.geojson') && !file.name.toLowerCase().endsWith('.json')) {
                showStatus('GeoJSONファイル（.geojson または .json）を選択してください', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const geoJSON = JSON.parse(e.target.result);
                    loadGeoJSON(geoJSON);
                    showStatus('GeoJSONファイルが正常に読み込まれました', 'success');
                } catch (error) {
                    showStatus('ファイルの解析エラー: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }
        
        // GeoTIFFファイル処理関数
        function handleGeoTIFFFile(file) {
            if (!file.name.toLowerCase().endsWith('.tif') && !file.name.toLowerCase().endsWith('.tiff')) {
                showGeoTIFFStatus('GeoTIFFファイル（.tif または .tiff）を選択してください', 'error');
                return;
            }
            
            showGeoTIFFStatus('GeoTIFFファイルを読み込み中...', 'info');
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    await loadGeoTIFF(arrayBuffer);
                    showGeoTIFFStatus('GeoTIFFファイルが正常に読み込まれました', 'success');
                } catch (error) {
                    console.error('GeoTIFF読み込みエラー:', error);
                    showGeoTIFFStatus('GeoTIFFファイルの読み込みエラー: ' + error.message, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // GeoTIFF読み込み関数
        async function loadGeoTIFF(arrayBuffer) {
            try {
                // 既存のGeoTIFFレイヤーを削除
                removeGeoTIFF();
                
                // ファイルサイズをチェック
                const fileSizeMB = arrayBuffer.byteLength / (1024 * 1024);
                console.log(`GeoTIFFファイルサイズ: ${fileSizeMB.toFixed(2)} MB`);
                
                if (fileSizeMB > 50) {
                    throw new Error(`ファイルサイズが大きすぎます (${fileSizeMB.toFixed(1)}MB)。50MB以下のファイルを使用してください。`);
                }
                
                // GeoTIFFを解析
                const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
                const image = await tiff.getImage();
                
                // 画像サイズを取得
                const width = image.getWidth();
                const height = image.getHeight();
                const pixelCount = width * height;
                
                console.log(`画像サイズ: ${width}x${height} (${(pixelCount / 1000000).toFixed(1)}M pixels)`);
                
                // 大きすぎる画像をチェック
                if (pixelCount > 10000000) { // 10M pixels
                    throw new Error(`画像サイズが大きすぎます (${width}x${height})。より小さな解像度の画像を使用してください。`);
                }
                
                // 地理情報を取得
                const bbox = image.getBoundingBox();
                
                // リサンプリングサイズを決定（最大2048x2048）
                const maxSize = 2048;
                let displayWidth = width;
                let displayHeight = height;
                
                if (width > maxSize || height > maxSize) {
                    const scale = Math.min(maxSize / width, maxSize / height);
                    displayWidth = Math.floor(width * scale);
                    displayHeight = Math.floor(height * scale);
                    console.log(`リサンプリング: ${width}x${height} → ${displayWidth}x${displayHeight}`);
                }
                
                // ラスターデータを読み込み（リサンプリング）
                const rasters = await image.readRasters({
                    width: displayWidth,
                    height: displayHeight,
                    resampleMethod: 'bilinear'
                });
                
                // Canvasを作成
                const canvas = document.createElement('canvas');
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                const ctx = canvas.getContext('2d');
                
                // ImageDataを作成
                const imageData = ctx.createImageData(displayWidth, displayHeight);
                const data = imageData.data;
                
                // RGBまたは単一バンドの処理
                const chunkSize = 10000;
                
                if (rasters.length >= 3) {
                    // RGBデータの場合
                    const redBand = rasters[0];
                    const greenBand = rasters[1];
                    const blueBand = rasters[2];
                    
                    for (let i = 0; i < redBand.length; i += chunkSize) {
                        const endIndex = Math.min(i + chunkSize, redBand.length);
                        
                        for (let j = i; j < endIndex; j++) {
                            const pixelIndex = j * 4;
                            
                            // RGBデータをそのまま使用
                            data[pixelIndex] = redBand[j] || 0;     // R
                            data[pixelIndex + 1] = greenBand[j] || 0; // G
                            data[pixelIndex + 2] = blueBand[j] || 0;  // B
                            data[pixelIndex + 3] = 255;              // A
                        }
                        
                        // UIをブロックしないように少し待機
                        if (i % (chunkSize * 5) === 0) {
                            showGeoTIFFStatus(`処理中... ${Math.round((i / redBand.length) * 100)}%`, 'info');
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    }
                } else {
                    // 単一バンドの場合はグレースケール
                    const raster = rasters[0];
                    
                    for (let i = 0; i < raster.length; i += chunkSize) {
                        const endIndex = Math.min(i + chunkSize, raster.length);
                        
                        for (let j = i; j < endIndex; j++) {
                            const value = raster[j];
                            const pixelIndex = j * 4;
                            
                            if (value !== null && value !== undefined && !isNaN(value)) {
                                // 値をグレースケール（0-255）に正規化
                                const gray = Math.max(0, Math.min(255, value));
                                data[pixelIndex] = gray;     // R
                                data[pixelIndex + 1] = gray; // G
                                data[pixelIndex + 2] = gray; // B
                                data[pixelIndex + 3] = 255;  // A
                            } else {
                                // 無効な値は透明にする
                                data[pixelIndex] = 0;
                                data[pixelIndex + 1] = 0;
                                data[pixelIndex + 2] = 0;
                                data[pixelIndex + 3] = 0;
                            }
                        }
                        
                        // UIをブロックしないように少し待機
                        if (i % (chunkSize * 5) === 0) {
                            showGeoTIFFStatus(`処理中... ${Math.round((i / raster.length) * 100)}%`, 'info');
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                geotiffCanvas = canvas;
                
                // MapLibre GLにソースとして追加
                map.addSource('geotiff', {
                    type: 'canvas',
                    canvas: canvas,
                    coordinates: [
                        [bbox[0], bbox[3]], // 左上
                        [bbox[2], bbox[3]], // 右上
                        [bbox[2], bbox[1]], // 右下
                        [bbox[0], bbox[1]]  // 左下
                    ]
                });
                
                // レイヤーを追加（GeoJSONレイヤーの下に配置）
                const beforeLayer = map.getLayer('geojson-fill') ? 'geojson-fill' : undefined;
                map.addLayer({
                    id: 'geotiff-layer',
                    type: 'raster',
                    source: 'geotiff',
                    paint: {
                        'raster-opacity': parseInt(geotiffOpacity.value) / 100
                    }
                }, beforeLayer);
                
                currentGeoTIFF = { tiff, image, bbox };
                geotiffRemove.style.display = 'block';
                
                // マップをGeoTIFFの範囲に合わせる
                fitMapToGeoTIFF(bbox);
                
                // GeoTIFFコントロールパネルを展開
                geotiffControls.classList.remove('minimized');
                setTimeout(adjustPanelPositions, 100);
                
                console.log('GeoTIFF読み込み完了:', {
                    originalSize: `${width}x${height}`,
                    displaySize: `${displayWidth}x${displayHeight}`,
                    bbox: bbox,
                    bands: rasters.length
                });
                
            } catch (error) {
                console.error('GeoTIFF処理エラー:', error);
                throw error;
            }
        }
        
        // GeoTIFFをCanvasに描画する関数
        // GeoTIFF削除関数
        function removeGeoTIFF() {
            if (map.getLayer('geotiff-layer')) {
                map.removeLayer('geotiff-layer');
            }
            if (map.getSource('geotiff')) {
                map.removeSource('geotiff');
            }
            
            currentGeoTIFF = null;
            geotiffCanvas = null;
            geotiffRemove.style.display = 'none';
            geotiffStatus.style.display = 'none';
            geotiffInput.value = '';
            
            // GeoTIFFコントロールパネルを最小化
            geotiffControls.classList.add('minimized');
            setTimeout(adjustPanelPositions, 100);
        }
        
        // GeoTIFFステータス表示関数
        function showGeoTIFFStatus(message, type) {
            geotiffStatus.textContent = message;
            geotiffStatus.className = `geotiff-status ${type}`;
            geotiffStatus.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    geotiffStatus.style.display = 'none';
                }, 3000);
            } else if (type === 'info') {
                // info メッセージは手動で消すか、次のメッセージまで表示
            }
        }
        
        // 背景地図変更関数
        function changeBasemap(basemapType) {
            if (!basemapStyles[basemapType]) {
                console.error('Unknown basemap type:', basemapType);
                return;
            }
            
            // 現在のGeoJSONデータを保存
            const savedGeoJSON = currentGeoJSON;
            const savedField = currentField;
            const savedHeatmapMode = isHeatmapMode;
            const savedLabelMode = isLabelMode;
            
            // マップスタイルを変更
            map.setStyle(basemapStyles[basemapType]);
            
            // スタイル変更完了後にGeoJSONレイヤーを再構築
            map.once('styledata', () => {
                if (savedGeoJSON) {
                    // GeoJSONデータを再追加
                    map.addSource('geojson', {
                        'type': 'geojson',
                        'data': savedGeoJSON
                    });
                    
                    // レイヤーを再構築
                    map.addLayer({
                        'id': 'geojson-fill',
                        'type': 'fill',
                        'source': 'geojson',
                        'paint': {
                            'fill-color': '#088',
                            'fill-opacity': 0.5
                        }
                    });
                    
                    map.addLayer({
                        'id': 'geojson-line',
                        'type': 'line',
                        'source': 'geojson',
                        'paint': {
                            'line-color': '#088',
                            'line-width': parseFloat(lineWidth.value)
                        }
                    });
                    
                    // 表示設定を復元
                    currentField = savedField;
                    isHeatmapMode = savedHeatmapMode;
                    isLabelMode = savedLabelMode;
                    
                    // フィールド選択を復元
                    if (currentField) {
                        fieldSelect.value = currentField;
                        analyzeField();
                        updateVisualization();
                    }
                }
                
                // GeoTIFFレイヤーを再構築
                if (currentGeoTIFF && geotiffCanvas) {
                    map.addSource('geotiff', {
                        type: 'canvas',
                        canvas: geotiffCanvas,
                        coordinates: [
                            [currentGeoTIFF.bbox[0], currentGeoTIFF.bbox[3]], // 左上
                            [currentGeoTIFF.bbox[2], currentGeoTIFF.bbox[3]], // 右上
                            [currentGeoTIFF.bbox[2], currentGeoTIFF.bbox[1]], // 右下
                            [currentGeoTIFF.bbox[0], currentGeoTIFF.bbox[1]]  // 左下
                        ]
                    });
                    
                    const beforeLayer = map.getLayer('geojson-fill') ? 'geojson-fill' : undefined;
                    map.addLayer({
                        id: 'geotiff-layer',
                        type: 'raster',
                        source: 'geotiff',
                        paint: {
                            'raster-opacity': parseInt(geotiffOpacity.value) / 100
                        }
                    }, beforeLayer);
                }
                
                // 背景地図の透明度を適用
                const opacity = parseInt(basemapOpacity.value) / 100;
                if (map.getLayer('basemap')) {
                    map.setPaintProperty('basemap', 'raster-opacity', opacity);
                }
            });
        }
        
        // GeoJSON読み込み関数
        function loadGeoJSON(geoJSON) {
            // レイヤーIDを生成
            geoJSONLayerCounter++;
            const layerId = isFirstGeoJSON ? 'geojson' : `geojson-${geoJSONLayerCounter}`;
            
            // 最初のGeoJSONの場合のみ、現在のGeoJSONとして管理
            if (isFirstGeoJSON) {
                currentGeoJSON = geoJSON;
                isFirstGeoJSON = false;
                
                // 既存のGeoJSONレイヤーを削除（初回のみ）
                if (map.getSource('geojson')) {
                    // Fill レイヤーの削除
                    if (map.getLayer('geojson-fill')) {
                        map.removeLayer('geojson-fill');
                    }
                    // Line レイヤーの削除
                    if (map.getLayer('geojson-line')) {
                        map.removeLayer('geojson-line');
                    }
                    // Circle レイヤーの削除
                    if (map.getLayer('geojson-circle')) {
                        map.removeLayer('geojson-circle');
                    }
                    // Symbol レイヤーの削除
                    if (map.getLayer('geojson-symbol')) {
                        map.removeLayer('geojson-symbol');
                    }
                    // Heatmap レイヤーの削除
                    if (map.getLayer('geojson-heatmap')) {
                        map.removeLayer('geojson-heatmap');
                    }
                    map.removeSource('geojson');
                }
            }
            
            // 新しいソースを追加
            map.addSource(layerId, {
                'type': 'geojson',
                'data': geoJSON
            });
            
            // ジオメトリタイプを判定
            const geometryTypes = new Set();
            if (geoJSON.features) {
                geoJSON.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.type) {
                        geometryTypes.add(feature.geometry.type);
                    }
                });
            }
            
            // ジオメトリタイプ別の色設定
            const getColors = () => {
                if (layerId === 'geojson') {
                    // 最初のレイヤーは従来の色
                    return {
                        polygon: '#088',
                        line: '#088',
                        point: '#088'
                    };
                } else {
                    // 追加レイヤーはジオメトリタイプ別に色分け
                    return {
                        polygon: '#088', // ポリゴンは従来通り
                        line: '#2196f3', // 青系
                        point: '#f44336' // 赤系
                    };
                }
            };
            
            const colors = getColors();
            
            // ジオメトリタイプに応じてレイヤーを追加
            // ポリゴンまたはマルチポリゴンが含まれている場合、塗りつぶしレイヤーを追加
            if (geometryTypes.has('Polygon') || geometryTypes.has('MultiPolygon')) {
                map.addLayer({
                    'id': `${layerId}-fill`,
                    'type': 'fill',
                    'source': layerId,
                    'filter': ['in', ['geometry-type'], ['literal', ['Polygon', 'MultiPolygon']]],
                    'paint': {
                        'fill-color': colors.polygon,
                        'fill-opacity': 0.5
                    }
                });
            }
            
            // ライン、ポリゴン、マルチライン、マルチポリゴンが含まれている場合、ラインレイヤーを追加
            if (geometryTypes.has('LineString') || geometryTypes.has('MultiLineString') || 
                geometryTypes.has('Polygon') || geometryTypes.has('MultiPolygon')) {
                map.addLayer({
                    'id': `${layerId}-line`,
                    'type': 'line',
                    'source': layerId,
                    'filter': ['in', ['geometry-type'], ['literal', ['LineString', 'MultiLineString', 'Polygon', 'MultiPolygon']]],
                    'paint': {
                        'line-color': colors.line,
                        'line-width': parseFloat(lineWidth.value)
                    }
                });
            }
            
            // ポイントまたはマルチポイントが含まれている場合、ポイントレイヤーを追加
            if (geometryTypes.has('Point') || geometryTypes.has('MultiPoint')) {
                map.addLayer({
                    'id': `${layerId}-circle`,
                    'type': 'circle',
                    'source': layerId,
                    'filter': ['in', ['geometry-type'], ['literal', ['Point', 'MultiPoint']]],
                    'paint': {
                        'circle-color': colors.point,
                        'circle-radius': 6,
                        'circle-stroke-color': '#fff',
                        'circle-stroke-width': 2
                    }
                });
            }
            
            // 最初のGeoJSONの場合のみ、UI更新処理を実行
            if (layerId === 'geojson') {
                // ジオメトリタイプ情報を表示
                updateGeometryInfo(geometryTypes);
                
                // フィールド選択肢を更新
                updateFieldOptions();
                
                // コントロールパネルを表示・展開、GeoJSON選択パネルを最小化
                controls.style.display = 'block';
                controls.classList.remove('minimized');
                fileInputContainer.classList.add('minimized');
                
                // マップイベントを設定
                setupLayerEvents();
                
                setTimeout(adjustPanelPositions, 100);
            }
            
            // マップを GeoJSON の範囲に合わせる
            fitMapToGeoJSON(geoJSON);
        }
        
        // GeoJSONレイヤーを地図に追加する関数
        
        // ジオメトリタイプ情報更新関数
        function updateGeometryInfo(geometryTypes) {
            const geometryInfo = document.getElementById('geometryInfo');
            if (!geometryInfo) {
                // ジオメトリ情報表示要素を作成
                const infoDiv = document.getElementById('fieldInfo');
                const newDiv = document.createElement('div');
                newDiv.id = 'geometryInfo';
                newDiv.style.marginTop = '5px';
                infoDiv.parentNode.insertBefore(newDiv, infoDiv);
            }
            
            const typeNames = {
                'Point': 'ポイント',
                'MultiPoint': 'マルチポイント',
                'LineString': 'ライン',
                'MultiLineString': 'マルチライン',
                'Polygon': 'ポリゴン',
                'MultiPolygon': 'マルチポリゴン'
            };
            
            const typeList = Array.from(geometryTypes).map(type => typeNames[type] || type).join(', ');
            document.getElementById('geometryInfo').innerHTML = `ジオメトリ: ${typeList}`;
        }
        
        // フィールド選択肢更新関数
        function updateFieldOptions() {
            fieldSelect.innerHTML = '<option value="">選択してください</option>';
            
            if (!currentGeoJSON || !currentGeoJSON.features || currentGeoJSON.features.length === 0) return;
            
            // 全フィーチャのプロパティからフィールド一覧を取得
            const allFields = new Set();
            currentGeoJSON.features.forEach(feature => {
                if (feature.properties) {
                    Object.keys(feature.properties).forEach(key => allFields.add(key));
                }
            });
            
            Array.from(allFields).sort().forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                fieldSelect.appendChild(option);
            });
        }
        
        // フィールド分析関数
        function analyzeField() {
            if (!currentField || !currentGeoJSON) return;
            
            const values = [];
            let isNumeric = true;
            let isInteger = true;
            let numericValues = [];
            
            currentGeoJSON.features.forEach(feature => {
                const value = feature.properties[currentField];
                if (value !== null && value !== undefined && value !== '') {
                    values.push(value);
                    
                    // 数値判定
                    const numValue = parseFloat(value);
                    if (isNaN(value) || isNaN(numValue)) {
                        isNumeric = false;
                        isInteger = false;
                    } else {
                        numericValues.push(numValue);
                        // 整数判定
                        if (isInteger && !Number.isInteger(numValue)) {
                            isInteger = false;
                        }
                    }
                }
            });
            
            fieldStats = {
                isNumeric: isNumeric,
                isInteger: isInteger,
                values: values,
                numericValues: numericValues,
                uniqueCount: new Set(values).size
            };
            
            if (isNumeric && numericValues.length > 0) {
                fieldStats.min = Math.min(...numericValues);
                fieldStats.max = Math.max(...numericValues);
                fieldStats.avg = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
            }
            
            updateFieldInfo();
        }
        
        // フィールド情報更新関数
        function updateFieldInfo() {
            if (!fieldStats) {
                fieldInfo.textContent = '';
                return;
            }
            
            let dataType = 'テキスト';
            if (fieldStats.isNumeric) {
                dataType = fieldStats.isInteger ? '整数' : '小数';
            }
            
            let info = `タイプ: ${dataType}, `;
            info += `ユニーク値: ${fieldStats.uniqueCount}`;
            
            if (fieldStats.isNumeric) {
                const minDisplay = fieldStats.isInteger ? fieldStats.min.toString() : fieldStats.min.toFixed(2);
                const maxDisplay = fieldStats.isInteger ? fieldStats.max.toString() : fieldStats.max.toFixed(2);
                const avgDisplay = fieldStats.isInteger ? Math.round(fieldStats.avg).toString() : fieldStats.avg.toFixed(2);
                
                info += `<br>範囲: ${minDisplay} - ${maxDisplay}`;
                info += `<br>平均: ${avgDisplay}`;
                info += `<br>数値データ: ${fieldStats.numericValues.length}/${fieldStats.values.length}`;
            }
            
            fieldInfo.innerHTML = info;
            
            // ヒートマップモードのチェックボックス表示制御
            if (fieldStats.isNumeric && fieldStats.numericValues.length > 0) {
                heatmapMode.parentElement.style.display = 'block';
            } else {
                heatmapMode.parentElement.style.display = 'none';
                heatmapMode.checked = false;
                isHeatmapMode = false;
            }
        }
        
        // 可視化更新関数
        function updateVisualization() {
            // レイヤーの色をリセット
            if (map.getLayer('geojson-fill')) {
                map.setPaintProperty('geojson-fill', 'fill-color', '#088');
            }
            if (map.getLayer('geojson-line')) {
                map.setPaintProperty('geojson-line', 'line-color', '#088');
            }
            if (map.getLayer('geojson-point')) {
                map.setPaintProperty('geojson-point', 'circle-color', '#088');
            }
            
            // ヒートマップモードの処理
            if (isHeatmapMode && fieldStats && fieldStats.isNumeric) {
                updateHeatmap();
                colorLegend.style.display = 'block';
                updateColorLegend();
            } else {
                colorLegend.style.display = 'none';
            }
            
            // ラベルモードの処理（ヒートマップとは独立）
            if (isLabelMode) {
                updateLabels();
            } else {
                // ラベル非表示
                if (map.getLayer('geojson-labels')) {
                    map.removeLayer('geojson-labels');
                }
            }
        }
        
        // 可視化クリア関数
        function clearVisualization() {
            // ラベルレイヤーを削除
            if (map.getLayer('geojson-labels')) {
                map.removeLayer('geojson-labels');
            }
            
            // ポリゴンの色を元に戻す
            if (map.getLayer('geojson-fill')) {
                map.setPaintProperty('geojson-fill', 'fill-color', '#088');
            }
            
            colorLegend.style.display = 'none';
            fieldInfo.innerHTML = '';
        }
        
        // ヒートマップ更新関数
        function updateHeatmap() {
            if (!currentField || !currentGeoJSON || !fieldStats.isNumeric) return;
            
            // データ範囲に0が含まれるかチェック
            const includesZero = fieldStats.min <= 0 && fieldStats.max >= 0;
            
            if (includesZero) {
                // 0基準の色分け（プラス=赤系、マイナス=青系、ゼロ=白）
                console.log('0基準の色分けを適用:', fieldStats.min, 'から', fieldStats.max);
                
                // 色分け表現を直接構築
                const colorExpression = [
                    'case',
                    // 数値でない場合はデフォルト色（グレー）
                    ['!=', ['typeof', ['get', currentField]], 'number'],
                    '#cccccc',
                    // 数値の場合は interpolate で色分け
                    [
                        'interpolate',
                        ['linear'],
                        ['get', currentField]
                    ]
                ];
                
                // マイナス側の色分け点を追加
                if (fieldStats.min < 0) {
                    colorExpression[3].push(fieldStats.min, 'rgb(0,0,255)'); // 最小値=青
                    colorExpression[3].push(fieldStats.min * 0.5, 'rgb(128,128,255)'); // 中間=薄い青
                }
                
                // ゼロ点を追加
                colorExpression[3].push(0, 'rgb(255,255,255)'); // ゼロ=白
                
                // プラス側の色分け点を追加
                if (fieldStats.max > 0) {
                    colorExpression[3].push(fieldStats.max * 0.5, 'rgb(255,128,128)'); // 中間=薄い赤
                    colorExpression[3].push(fieldStats.max, 'rgb(255,0,0)'); // 最大値=赤
                }
                
                console.log('色分け表現:', colorExpression);
                
                // すべてのレイヤータイプに色分けを適用
                if (map.getLayer('geojson-fill')) {
                    map.setPaintProperty('geojson-fill', 'fill-color', colorExpression);
                }
                if (map.getLayer('geojson-line')) {
                    map.setPaintProperty('geojson-line', 'line-color', colorExpression);
                }
                if (map.getLayer('geojson-point')) {
                    map.setPaintProperty('geojson-point', 'circle-color', colorExpression);
                }
                
            } else {
                // 0を含まない場合：従来の最大最小基準
                console.log('従来の色分けを適用:', fieldStats.min, 'から', fieldStats.max);
                
                const colorExpression = [
                    'case',
                    // 数値でない場合はデフォルト色（グレー）
                    ['!=', ['typeof', ['get', currentField]], 'number'],
                    '#cccccc',
                    // 数値の場合は interpolate で色分け
                    [
                        'interpolate',
                        ['linear'],
                        ['get', currentField]
                    ]
                ];
                
                // 5段階の色分け
                const steps = 5;
                for (let i = 0; i <= steps; i++) {
                    const ratio = i / steps;
                    const value = fieldStats.min + (fieldStats.max - fieldStats.min) * ratio;
                    const color = getHeatmapColor(ratio);
                    colorExpression[3].push(value, color);
                }
                
                // すべてのレイヤータイプに色分けを適用
                if (map.getLayer('geojson-fill')) {
                    map.setPaintProperty('geojson-fill', 'fill-color', colorExpression);
                }
                if (map.getLayer('geojson-line')) {
                    map.setPaintProperty('geojson-line', 'line-color', colorExpression);
                }
                if (map.getLayer('geojson-point')) {
                    map.setPaintProperty('geojson-point', 'circle-color', colorExpression);
                }
            }
        }
        
        // 0基準のヒートマップ色取得関数
        function getZeroBasedHeatmapColor(value, positiveMax, negativeMin) {
            // 0付近は白色で表示
            if (Math.abs(value) <= 0.1) {
                return 'rgb(255,255,255)'; // 白
            }
            
            if (value > 0 && positiveMax > 0) {
                // プラス側：白→赤系のグラデーション
                const intensity = Math.min(value / positiveMax, 1.0);
                
                if (intensity <= 0.5) {
                    // 白 → 薄いピンク
                    const factor = intensity * 2;
                    const red = 255;
                    const green = Math.round(255 * (1 - factor * 0.3));
                    const blue = Math.round(255 * (1 - factor * 0.3));
                    return `rgb(${red},${green},${blue})`;
                } else {
                    // 薄いピンク → 濃い赤
                    const factor = (intensity - 0.5) * 2;
                    const red = 255;
                    const green = Math.round(180 * (1 - factor));
                    const blue = Math.round(180 * (1 - factor));
                    return `rgb(${red},${green},${blue})`;
                }
            } else if (value < 0 && negativeMin < 0) {
                // マイナス側：白→青系のグラデーション
                const intensity = Math.min(Math.abs(value / negativeMin), 1.0);
                
                if (intensity <= 0.5) {
                    // 白 → 薄い水色
                    const factor = intensity * 2;
                    const red = Math.round(255 * (1 - factor * 0.3));
                    const green = Math.round(255 * (1 - factor * 0.1));
                    const blue = 255;
                    return `rgb(${red},${green},${blue})`;
                } else {
                    // 薄い水色 → 濃い青
                    const factor = (intensity - 0.5) * 2;
                    const red = Math.round(180 * (1 - factor));
                    const green = Math.round(230 * (1 - factor));
                    const blue = 255;
                    return `rgb(${red},${green},${blue})`;
                }
            } else {
                // フォールバック
                return 'rgb(255,255,255)'; // 白
            }
        }
        
        // ヒートマップ色取得関数
        function getHeatmapColor(ratio) {
            // 0%〜2%の範囲を青色で表示
            if (ratio >= 0 && ratio <= 0.02) {
                return 'rgb(0,0,255)'; // 青
            }
            
            // 98%〜100%の範囲を赤色で表示
            if (ratio >= 0.98 && ratio <= 1.0) {
                return 'rgb(255,0,0)'; // 赤
            }
            
            // 48%〜52%の範囲を白色で表示し、メリハリを強調
            if (ratio >= 0.48 && ratio <= 0.52) {
                return 'rgb(255,255,255)'; // 白
            }
            
            // 青→緑めの青→白→黄色が混じるオレンジ→赤のグラデーション
            const colors = [
                [0, 0, 255],     // 青 (0-2%)
                [0, 255, 216],   // 緑めの青 (25%)
                [255, 255, 255], // 白 (48-52%)
                [255, 217, 0],   // 黄色が混じるオレンジ (75%)
                [255, 0, 0]      // 赤 (98-100%)
            ];
            
            // 比率を調整（固定色範囲を除く）
            let adjustedRatio;
            if (ratio > 0.02 && ratio < 0.48) {
                // 2%〜48%の範囲を0〜0.5にマッピング
                adjustedRatio = ((ratio - 0.02) / 0.46) * 0.5;
            } else if (ratio > 0.52 && ratio < 0.98) {
                // 52%〜98%の範囲を0.5〜1にマッピング
                adjustedRatio = 0.5 + ((ratio - 0.52) / 0.46) * 0.5;
            } else {
                // フォールバック（通常は上の条件で処理される）
                adjustedRatio = ratio;
            }
            
            const scaledRatio = adjustedRatio * (colors.length - 1);
            const index = Math.floor(scaledRatio);
            const fraction = scaledRatio - index;
            
            if (index >= colors.length - 1) {
                return `rgb(${colors[colors.length - 1].join(',')})`;
            }
            
            const color1 = colors[index];
            const color2 = colors[index + 1];
            
            const r = Math.round(color1[0] + (color2[0] - color1[0]) * fraction);
            const g = Math.round(color1[1] + (color2[1] - color1[1]) * fraction);
            const b = Math.round(color1[2] + (color2[2] - color1[2]) * fraction);
            
            return `rgb(${r},${g},${b})`;
        }
        
        // 色分け凡例更新関数
        function updateColorLegend() {
            if (!fieldStats.isNumeric) return;
            
            legendContent.innerHTML = '';
            
            // 数値以外のデータがある場合は説明を追加
            if (fieldStats.values.length > fieldStats.numericValues.length) {
                const nonNumericItem = document.createElement('div');
                nonNumericItem.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = '#cccccc';
                
                const label = document.createElement('span');
                label.textContent = '非数値データ';
                
                nonNumericItem.appendChild(colorBox);
                nonNumericItem.appendChild(label);
                legendContent.appendChild(nonNumericItem);
            }
            
            // データ範囲に0が含まれるかチェック
            const includesZero = fieldStats.min <= 0 && fieldStats.max >= 0;
            
            if (includesZero) {
                // 0基準の凡例（シンプルに5段階で表示）
                
                // プラス側最大値
                if (fieldStats.max > 0) {
                    const legendItem1 = document.createElement('div');
                    legendItem1.className = 'legend-item';
                    
                    const colorBox1 = document.createElement('div');
                    colorBox1.className = 'legend-color';
                    colorBox1.style.backgroundColor = 'rgb(255,0,0)';
                    
                    const label1 = document.createElement('span');
                    label1.textContent = fieldStats.isInteger ? fieldStats.max.toString() : fieldStats.max.toFixed(2);
                    
                    legendItem1.appendChild(colorBox1);
                    legendItem1.appendChild(label1);
                    legendContent.appendChild(legendItem1);
                    
                    // プラス側中間値
                    const legendItem2 = document.createElement('div');
                    legendItem2.className = 'legend-item';
                    
                    const colorBox2 = document.createElement('div');
                    colorBox2.className = 'legend-color';
                    colorBox2.style.backgroundColor = 'rgb(255,128,128)';
                    
                    const label2 = document.createElement('span');
                    const midPositive = fieldStats.max * 0.5;
                    label2.textContent = fieldStats.isInteger ? Math.round(midPositive).toString() : midPositive.toFixed(2);
                    
                    legendItem2.appendChild(colorBox2);
                    legendItem2.appendChild(label2);
                    legendContent.appendChild(legendItem2);
                }
                
                // ゼロ値
                const zeroItem = document.createElement('div');
                zeroItem.className = 'legend-item';
                
                const zeroColorBox = document.createElement('div');
                zeroColorBox.className = 'legend-color';
                zeroColorBox.style.backgroundColor = 'rgb(255,255,255)';
                zeroColorBox.style.border = '1px solid #999';
                
                const zeroLabel = document.createElement('span');
                zeroLabel.textContent = '0';
                
                zeroItem.appendChild(zeroColorBox);
                zeroItem.appendChild(zeroLabel);
                legendContent.appendChild(zeroItem);
                
                // マイナス側
                if (fieldStats.min < 0) {
                    // マイナス側中間値
                    const legendItem3 = document.createElement('div');
                    legendItem3.className = 'legend-item';
                    
                    const colorBox3 = document.createElement('div');
                    colorBox3.className = 'legend-color';
                    colorBox3.style.backgroundColor = 'rgb(128,128,255)';
                    
                    const label3 = document.createElement('span');
                    const midNegative = fieldStats.min * 0.5;
                    label3.textContent = fieldStats.isInteger ? Math.round(midNegative).toString() : midNegative.toFixed(2);
                    
                    legendItem3.appendChild(colorBox3);
                    legendItem3.appendChild(label3);
                    legendContent.appendChild(legendItem3);
                    
                    // マイナス側最小値
                    const legendItem4 = document.createElement('div');
                    legendItem4.className = 'legend-item';
                    
                    const colorBox4 = document.createElement('div');
                    colorBox4.className = 'legend-color';
                    colorBox4.style.backgroundColor = 'rgb(0,0,255)';
                    
                    const label4 = document.createElement('span');
                    label4.textContent = fieldStats.isInteger ? fieldStats.min.toString() : fieldStats.min.toFixed(2);
                    
                    legendItem4.appendChild(colorBox4);
                    legendItem4.appendChild(label4);
                    legendContent.appendChild(legendItem4);
                }
                
            } else {
                // 0を含まない場合：従来の最大最小基準凡例
                const steps = 5;
                // 最高値から最小値の順で表示（逆順）
                for (let i = steps; i >= 0; i--) {
                    const ratio = i / steps;
                    const value = fieldStats.min + (fieldStats.max - fieldStats.min) * ratio;
                    const color = getHeatmapColor(ratio);
                    
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = color;
                    
                    const label = document.createElement('span');
                    // 整数の場合は小数点なし、小数の場合は2桁まで表示
                    label.textContent = fieldStats.isInteger ? Math.round(value).toString() : value.toFixed(2);
                    
                    legendItem.appendChild(colorBox);
                    legendItem.appendChild(label);
                    legendContent.appendChild(legendItem);
                }
            }
        }
        
        // ラベル更新関数
        function updateLabels() {
            // 既存のラベルレイヤーを削除
            if (map.getLayer('geojson-labels')) {
                map.removeLayer('geojson-labels');
            }
            
            if (!currentField || !currentGeoJSON) return;
            
            // ジオメトリタイプを判定
            const geometryTypes = new Set();
            if (currentGeoJSON.features) {
                currentGeoJSON.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.type) {
                        geometryTypes.add(feature.geometry.type);
                    }
                });
            }
            
            // ポイントデータが含まれているかチェック
            const hasPoints = geometryTypes.has('Point') || geometryTypes.has('MultiPoint');
            const hasNonPoints = geometryTypes.has('Polygon') || geometryTypes.has('MultiPolygon') || 
                               geometryTypes.has('LineString') || geometryTypes.has('MultiLineString');
            
            // ポイントデータのみの場合、ラベルを上にシフト
            let textAnchor = 'center';
            let textOffset = [0, 0];
            
            if (hasPoints && !hasNonPoints) {
                // ポイントデータのみの場合：ラベルを点の上に表示
                textAnchor = 'bottom';
                textOffset = [0, -1.5];  // 上方向にシフト
            } else if (hasPoints && hasNonPoints) {
                // 混合データの場合：ポイントには条件付きでオフセットを適用
                textAnchor = 'center';
                textOffset = [
                    'case',
                    ['in', ['geometry-type'], ['literal', ['Point', 'MultiPoint']]],
                    ['literal', [0, -1.5]],  // ポイントの場合は上にシフト
                    ['literal', [0, 0]]      // その他は中央
                ];
            }
            
            // ラベル表示用のレイヤーを追加
            const labelLayer = {
                'id': 'geojson-labels',
                'type': 'symbol',
                'source': 'geojson',
                'layout': {
                    'text-field': ['get', currentField],
                    'text-font': ['Open Sans Regular'],
                    'text-size': 12,
                    'text-anchor': textAnchor,
                    'text-offset': textOffset,
                    'text-allow-overlap': true,
                    'text-ignore-placement': false,
                    'visibility': 'visible'
                },
                'paint': {
                    'text-color': '#000',
                    'text-halo-color': '#fff',
                    'text-halo-width': 2,
                    'text-opacity': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        19, 0,      // ズームレベル19で完全非表示
                        20, 1       // ズームレベル20で完全表示
                    ]
                }
            };
            
            // 混合データの場合、text-anchorも条件付きで設定
            if (hasPoints && hasNonPoints) {
                labelLayer.layout['text-anchor'] = [
                    'case',
                    ['in', ['geometry-type'], ['literal', ['Point', 'MultiPoint']]],
                    'bottom',    // ポイントの場合は下寄せ（ラベルが上に表示される）
                    'center'     // その他は中央
                ];
            }
            
            map.addLayer(labelLayer);
            
            // ポリゴンの色はヒートマップモードでない場合のみリセット
            if (!isHeatmapMode && map.getLayer('geojson-fill')) {
                map.setPaintProperty('geojson-fill', 'fill-color', '#088');
            }
        }
        
        // マップをGeoJSONの範囲に合わせる関数
        function fitMapToGeoJSON(geoJSON) {
            if (!geoJSON.features || geoJSON.features.length === 0) return;
            
            const bounds = new maplibregl.LngLatBounds();
            
            geoJSON.features.forEach(feature => {
                if (!feature.geometry) return;
                
                switch (feature.geometry.type) {
                    case 'Point':
                        bounds.extend(feature.geometry.coordinates);
                        break;
                        
                    case 'MultiPoint':
                        feature.geometry.coordinates.forEach(coord => {
                            bounds.extend(coord);
                        });
                        break;
                        
                    case 'LineString':
                        feature.geometry.coordinates.forEach(coord => {
                            bounds.extend(coord);
                        });
                        break;
                        
                    case 'MultiLineString':
                        feature.geometry.coordinates.forEach(line => {
                            line.forEach(coord => {
                                bounds.extend(coord);
                            });
                        });
                        break;
                        
                    case 'Polygon':
                        feature.geometry.coordinates[0].forEach(coord => {
                            bounds.extend(coord);
                        });
                        break;
                        
                    case 'MultiPolygon':
                        feature.geometry.coordinates.forEach(polygon => {
                            polygon[0].forEach(coord => {
                                bounds.extend(coord);
                            });
                        });
                        break;
                        
                    case 'GeometryCollection':
                        // GeometryCollectionの場合は再帰的に処理
                        feature.geometry.geometries.forEach(geometry => {
                            const tempFeature = { geometry: geometry };
                            fitMapToGeoJSON({ features: [tempFeature] });
                        });
                        break;
                        
                    default:
                        console.warn('未対応のジオメトリタイプ:', feature.geometry.type);
                }
            });
            
            // boundsが有効な場合のみ移動
            if (!bounds.isEmpty()) {
                map.fitBounds(bounds, { padding: 50 });
            } else {
                console.warn('有効な座標が見つかりませんでした');
            }
        }
        
        // マップをGeoTIFFの範囲に合わせる関数
        function fitMapToGeoTIFF(bbox) {
            if (!bbox || bbox.length !== 4) {
                console.warn('GeoTIFFのbbox情報が無効です:', bbox);
                return;
            }
            
            // bbox: [minX, minY, maxX, maxY] 形式
            const [minX, minY, maxX, maxY] = bbox;
            
            // MapLibre GLのLngLatBounds形式に変換
            const bounds = new maplibregl.LngLatBounds([minX, minY], [maxX, maxY]);
            
            // マップを範囲に合わせる
            map.fitBounds(bounds, { 
                padding: 50,
                duration: 1000  // アニメーション時間を指定
            });
            
            console.log('GeoTIFFの範囲に移動:', { minX, minY, maxX, maxY });
        }
        
        // ステータス表示関数
        function showStatus(message, type) {
            status.textContent = message;
            status.className = `status ${type}`;
            
            if (type === 'success') {
                setTimeout(() => {
                    status.textContent = '';
                    status.className = 'status';
                }, 3000);
            }
        }
        
        // マップクリックイベント（フィーチャ情報表示）- すべてのレイヤータイプに対応
        function addMapClickEvents() {
            const layers = ['geojson-fill', 'geojson-line', 'geojson-point'];
            
            layers.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.on('click', layerId, (e) => {
                        const properties = e.features[0].properties;
                        let popupContent = '<h4>フィーチャ情報</h4>';
                        
                        Object.keys(properties).forEach(key => {
                            popupContent += `<p><strong>${key}:</strong> ${properties[key]}</p>`;
                        });
                        
                        new maplibregl.Popup()
                            .setLngLat(e.lngLat)
                            .setHTML(popupContent)
                            .addTo(map);
                    });
                    
                    // マウスカーソル変更
                    map.on('mouseenter', layerId, () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    
                    map.on('mouseleave', layerId, () => {
                        map.getCanvas().style.cursor = '';
                    });
                }
            });
        }
        
        // レイヤー追加後にイベントを設定するためのヘルパー関数
        function setupLayerEvents() {
            // 既存のイベントをクリア（重複防止）
            map.off('click');
            map.off('mouseenter');
            map.off('mouseleave');
            
            // 新しいイベントを追加
            addMapClickEvents();
        }
        
        // パネル位置調整関数
        function adjustPanelPositions() {
            let currentTop = 10;
            
            // GeoJSON選択パネル
            if (!fileInputContainer.classList.contains('minimized')) {
                fileInputContainer.style.top = currentTop + 'px';
                currentTop += fileInputContainer.offsetHeight + 10;
            } else {
                fileInputContainer.style.top = currentTop + 'px';
                currentTop += 60; // 最小化時の高さ + マージン
            }
            
            // 表示設定パネル
            if (controls.style.display !== 'none') {
                if (!controls.classList.contains('minimized')) {
                    controls.style.top = currentTop + 'px';
                    currentTop += controls.offsetHeight + 10;
                } else {
                    controls.style.top = currentTop + 'px';
                    currentTop += 60; // 最小化時の高さ + マージン
                }
            }
            
            // GeoTIFFパネル
            if (!geotiffControls.classList.contains('minimized')) {
                geotiffControls.style.top = currentTop + 'px';
                currentTop += geotiffControls.offsetHeight + 10;
            } else {
                geotiffControls.style.top = currentTop + 'px';
                currentTop += 60; // 最小化時の高さ + マージン
            }
            
            // 計測パネル
            if (!measureControls.classList.contains('minimized')) {
                measureControls.style.top = currentTop + 'px';
                currentTop += measureControls.offsetHeight + 10;
            } else {
                measureControls.style.top = currentTop + 'px';
                currentTop += 60; // 最小化時の高さ + マージン
            }
            
            // ベースマップパネル
            basemapControls.style.bottom = '10px';
            basemapControls.style.top = 'auto';
            basemapControls.style.left = '10px';
        }
        
        // 計測開始関数
        function startMeasure(mode) {
            // 既存の計測をクリア
            clearMeasurements();
            
            measureMode = mode;
            measurePoints = [];
            
            // ボタンの状態を更新
            measureDistance.classList.remove('active');
            measureArea.classList.remove('active');
            
            if (mode === 'distance') {
                measureDistance.classList.add('active');
                measureResult.textContent = '地図上をクリックして距離を計測してください';
                map.getCanvas().style.cursor = 'crosshair';
            } else if (mode === 'area') {
                measureArea.classList.add('active');
                measureResult.textContent = '地図上をクリックして面積を計測してください（3点以上）';
                map.getCanvas().style.cursor = 'crosshair';
            }
            
            // マップクリックイベントを追加
            map.on('click', handleMeasureClick);
        }
        
        // 計測クリックハンドラ
        function handleMeasureClick(e) {
            if (!measureMode) return;
            
            const point = [e.lngLat.lng, e.lngLat.lat];
            measurePoints.push(point);
            
            // 小さな丸のマーカーを追加
            const markerElement = document.createElement('div');
            markerElement.style.width = '8px';
            markerElement.style.height = '8px';
            markerElement.style.backgroundColor = '#ff6b35';
            markerElement.style.borderRadius = '50%';
            markerElement.style.border = '2px solid white';
            markerElement.style.boxShadow = '0 0 4px rgba(0,0,0,0.3)';
            
            const marker = new maplibregl.Marker({ element: markerElement })
                .setLngLat(point)
                .addTo(map);
            measureMarkers.push(marker);
            
            if (measureMode === 'distance') {
                handleDistanceMeasure();
            } else if (measureMode === 'area') {
                handleAreaMeasure();
            }
        }
        
        // 距離計測処理
        function handleDistanceMeasure() {
            if (measurePoints.length === 1) {
                measureResult.textContent = '次の点をクリックしてください';
                return;
            }
            
            // 線を描画
            if (measurePoints.length >= 2) {
                const lastTwoPoints = measurePoints.slice(-2);
                
                // 既存のソースとレイヤーがあるかチェック
                if (!map.getSource('measure-line')) {
                    map.addSource('measure-line', {
                        type: 'geojson',
                        data: {
                            type: 'Feature',
                            geometry: {
                                type: 'LineString',
                                coordinates: measurePoints
                            }
                        }
                    });
                    
                    map.addLayer({
                        id: 'measure-line',
                        type: 'line',
                        source: 'measure-line',
                        paint: {
                            'line-color': '#ff6b35',
                            'line-width': 3
                        }
                    });
                } else {
                    // 既存のソースを更新
                    map.getSource('measure-line').setData({
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: measurePoints
                        }
                    });
                }
            }
            
            // 総距離を計算
            let totalDistance = 0;
            for (let i = 1; i < measurePoints.length; i++) {
                totalDistance += calculateDistance(measurePoints[i-1], measurePoints[i]);
            }
            
            measureResult.textContent = `距離: ${formatDistance(totalDistance)} (クリックで続行、Escで終了)`;
        }
        
        // 面積計測処理
        function handleAreaMeasure() {
            if (measurePoints.length < 3) {
                measureResult.textContent = `${3 - measurePoints.length}点以上必要です`;
                return;
            }
            
            // ポリゴンを描画
            const polygonCoords = [...measurePoints, measurePoints[0]]; // 閉じたポリゴン
            
            if (!map.getSource('measure-polygon')) {
                map.addSource('measure-polygon', {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Polygon',
                            coordinates: [polygonCoords]
                        }
                    }
                });
                
                map.addLayer({
                    id: 'measure-polygon-fill',
                    type: 'fill',
                    source: 'measure-polygon',
                    paint: {
                        'fill-color': '#ff6b35',
                        'fill-opacity': 0.3
                    }
                });
                
                map.addLayer({
                    id: 'measure-polygon-line',
                    type: 'line',
                    source: 'measure-polygon',
                    paint: {
                        'line-color': '#ff6b35',
                        'line-width': 3
                    }
                });
            } else {
                // 既存のソースを更新
                map.getSource('measure-polygon').setData({
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [polygonCoords]
                    }
                });
            }
            
            // 面積を計算
            const area = calculatePolygonArea(measurePoints);
            measureResult.textContent = `面積: ${formatArea(area)} (クリックで続行、Escで終了)`;
        }
        
        // 計測をクリア
        function clearMeasurements() {
            measureMode = null;
            measurePoints = [];
            
            // マーカーを削除
            measureMarkers.forEach(marker => marker.remove());
            measureMarkers = [];
            
            // レイヤーとソースを削除
            if (map.getLayer('measure-line')) {
                map.removeLayer('measure-line');
                map.removeSource('measure-line');
            }
            if (map.getLayer('measure-polygon-fill')) {
                map.removeLayer('measure-polygon-fill');
            }
            if (map.getLayer('measure-polygon-line')) {
                map.removeLayer('measure-polygon-line');
            }
            if (map.getSource('measure-polygon')) {
                map.removeSource('measure-polygon');
            }
            
            // ボタンの状態をリセット
            measureDistance.classList.remove('active');
            measureArea.classList.remove('active');
            
            // カーソルをリセット
            map.getCanvas().style.cursor = '';
            
            // イベントリスナーを削除
            map.off('click', handleMeasureClick);
            
            measureResult.textContent = '';
        }
        
        // 2点間の距離を計算（メートル単位）
        function calculateDistance([lng1, lat1], [lng2, lat2]) {
            const R = 6371000; // 地球の半径（メートル）
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lng2 - lng1) * Math.PI / 180;
            
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }
        
        // ポリゴンの面積を計算（平方メートル単位）
        function calculatePolygonArea(coordinates) {
            if (coordinates.length < 3) return 0;
            
            let area = 0;
            const n = coordinates.length;
            
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                const [lng1, lat1] = coordinates[i];
                const [lng2, lat2] = coordinates[j];
                
                area += (lng2 - lng1) * (lat2 + lat1);
            }
            
            area = Math.abs(area) / 2;
            
            // 度からメートルへの概算変換（緯度による補正）
            const avgLat = coordinates.reduce((sum, coord) => sum + coord[1], 0) / coordinates.length;
            const latFactor = Math.cos(avgLat * Math.PI / 180);
            const meterPerDegree = 111320; // 1度あたりのメートル数（概算）
            
            return area * meterPerDegree * meterPerDegree * latFactor;
        }
        
        // 距離をフォーマット
        function formatDistance(meters) {
            if (meters < 1000) {
                return `${meters.toFixed(1)} m`;
            } else {
                return `${(meters / 1000).toFixed(2)} km`;
            }
        }
        
        // 面積をフォーマット
        function formatArea(squareMeters) {
            if (squareMeters < 10000) {
                return `${squareMeters.toFixed(1)} m²`;
            } else {
                return `${(squareMeters / 10000).toFixed(2)} ha`;
            }
        }
        
        
        // 初期パネル位置を調整
        setTimeout(adjustPanelPositions, 100);
    </script>
</body>
</html>